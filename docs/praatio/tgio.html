<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 6.4.2" />
    <title>praatio.tgio API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style type="text/css">/*! * Bootstrap Reboot v5.0.0-beta1 (https://getbootstrap.com/) * Copyright 2011-2020 The Bootstrap Authors * Copyright 2011-2020 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus{outline:dotted 1px;outline:-webkit-focus-ring-color auto 5px}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style type="text/css">/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style type="text/css">/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main{padding:2rem 3vw;}.git-button{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3, .pdoc h4{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../praatio.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;praatio</a>




                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Interval">Interval</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Interval.__init__">Interval</a>
                        </li>
                        <li>
                                <a class="variable" href="#Interval.start">start</a>
                        </li>
                        <li>
                                <a class="variable" href="#Interval.end">end</a>
                        </li>
                        <li>
                                <a class="variable" href="#Interval.label">label</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Point">Point</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Point.__init__">Point</a>
                        </li>
                        <li>
                                <a class="variable" href="#Point.time">time</a>
                        </li>
                        <li>
                                <a class="variable" href="#Point.label">label</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#intervalOverlapCheck">intervalOverlapCheck</a>
            </li>
            <li>
                    <a class="class" href="#TextgridCollisionException">TextgridCollisionException</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TextgridCollisionException.__init__">TextgridCollisionException</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TimelessTextgridTierException">TimelessTextgridTierException</a>
                            <ul class="memberlist">
                </ul>

            </li>
            <li>
                    <a class="class" href="#BadIntervalError">BadIntervalError</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BadIntervalError.__init__">BadIntervalError</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BadFormatException">BadFormatException</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BadFormatException.__init__">BadFormatException</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TextgridTier">TextgridTier</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TextgridTier.__init__">TextgridTier</a>
                        </li>
                        <li>
                                <a class="variable" href="#TextgridTier.tierType">tierType</a>
                        </li>
                        <li>
                                <a class="class" href="#TextgridTier.entryType">TextgridTier.entryType</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.appendTier">appendTier</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.deleteEntry">deleteEntry</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.find">find</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.getAsText">getAsText</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.new">new</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.sort">sort</a>
                        </li>
                        <li>
                                <a class="function" href="#TextgridTier.union">union</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PointTier">PointTier</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PointTier.__init__">PointTier</a>
                        </li>
                        <li>
                                <a class="variable" href="#PointTier.tierType">tierType</a>
                        </li>
                        <li>
                                <a class="class" href="#PointTier.entryType">PointTier.entryType</a>
                        </li>
                        <li>
                                <a class="function" href="#PointTier.crop">crop</a>
                        </li>
                        <li>
                                <a class="function" href="#PointTier.editTimestamps">editTimestamps</a>
                        </li>
                        <li>
                                <a class="function" href="#PointTier.getValuesAtPoints">getValuesAtPoints</a>
                        </li>
                        <li>
                                <a class="function" href="#PointTier.eraseRegion">eraseRegion</a>
                        </li>
                        <li>
                                <a class="function" href="#PointTier.insertEntry">insertEntry</a>
                        </li>
                        <li>
                                <a class="function" href="#PointTier.insertSpace">insertSpace</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntervalTier">IntervalTier</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntervalTier.__init__">IntervalTier</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntervalTier.tierType">tierType</a>
                        </li>
                        <li>
                                <a class="class" href="#IntervalTier.entryType">IntervalTier.entryType</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.crop">crop</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.difference">difference</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.editTimestamps">editTimestamps</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.eraseRegion">eraseRegion</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.getValuesInIntervals">getValuesInIntervals</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.getNonEntries">getNonEntries</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.insertEntry">insertEntry</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.insertSpace">insertSpace</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.intersection">intersection</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalTier.morph">morph</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Textgrid">Textgrid</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Textgrid.__init__">Textgrid</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.addTier">addTier</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.appendTextgrid">appendTextgrid</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.crop">crop</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.eraseRegion">eraseRegion</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.editTimestamps">editTimestamps</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.insertSpace">insertSpace</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.mergeTiers">mergeTiers</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.new">new</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.renameTier">renameTier</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.removeTier">removeTier</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.replaceTier">replaceTier</a>
                        </li>
                        <li>
                                <a class="function" href="#Textgrid.save">save</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#openTextgrid">openTextgrid</a>
            </li>
            <li>
                    <a class="function" href="#numToStr">numToStr</a>
            </li>
            <li>
                    <a class="function" href="#strToIntOrFloat">strToIntOrFloat</a>
            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../praatio.html">praatio</a>.tgio    </h1>

                        <div class="docstring"><p>Functions for reading/writing/manipulating textgrid files.</p>

<p>This file contains the main data structures for representing Textgrid data:
Textgrid, IntervalTier, and PointTier</p>

<p>A Textgrid is a container for multiple annotation tiers.  Tiers can contain
either interval data (IntervalTier) or point data (PointTier).
Tiers in a Textgrid are ordered and must contain a unique name.</p>

<p>openTextgrid() can be used to open a textgrid file.
<a href="#Textgrid.save">Textgrid.save()</a> can be used to save a Textgrid object to a file.</p>

<p>see the <strong>examples/</strong> directory for lots of examples using tgio.py</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for reading/writing/manipulating textgrid files.</span>

<span class="sd">This file contains the main data structures for representing Textgrid data:</span>
<span class="sd">Textgrid, IntervalTier, and PointTier</span>

<span class="sd">A Textgrid is a container for multiple annotation tiers.  Tiers can contain</span>
<span class="sd">either interval data (IntervalTier) or point data (PointTier).</span>
<span class="sd">Tiers in a Textgrid are ordered and must contain a unique name.</span>

<span class="sd">openTextgrid() can be used to open a textgrid file.</span>
<span class="sd">Textgrid.save() can be used to save a Textgrid object to a file.</span>

<span class="sd">see the **examples/** directory for lots of examples using tgio.py</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">wave</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">from</span> <span class="nn">praatio.utilities</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="n">INTERVAL_TIER</span> <span class="o">=</span> <span class="s2">&quot;IntervalTier&quot;</span>
<span class="n">POINT_TIER</span> <span class="o">=</span> <span class="s2">&quot;TextTier&quot;</span>
<span class="n">MIN_INTERVAL_LENGTH</span> <span class="o">=</span> <span class="mf">0.00000001</span>  <span class="c1"># Arbitrary threshold</span>

<span class="n">Interval</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Interval&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>  <span class="c1"># interval entry</span>
<span class="n">Point</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">])</span>  <span class="c1"># point entry</span>

<span class="n">TEXTGRID</span> <span class="o">=</span> <span class="s2">&quot;textgrid&quot;</span>
<span class="n">JSON</span> <span class="o">=</span> <span class="s2">&quot;json&quot;</span>
<span class="n">SUPPORTED_OUTPUT_FORMATS</span> <span class="o">=</span> <span class="p">[</span><span class="n">TEXTGRID</span><span class="p">,</span> <span class="n">JSON</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_escapeQuotes</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rel_tol</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span> <span class="n">abs_tol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_getWavDuration</span><span class="p">(</span><span class="n">wavFN</span><span class="p">):</span>
    <span class="s2">&quot;For internal use.  See praatio.audioio.WavQueryObj() for general use.&quot;</span>
    <span class="n">audiofile</span> <span class="o">=</span> <span class="n">wave</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">wavFN</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">audiofile</span><span class="o">.</span><span class="n">getparams</span><span class="p">()</span>
    <span class="n">framerate</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">nframes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nframes</span><span class="p">)</span> <span class="o">/</span> <span class="n">framerate</span>

    <span class="k">return</span> <span class="n">duration</span>


<span class="k">def</span> <span class="nf">_removeBlanks</span><span class="p">(</span><span class="n">tier</span><span class="p">):</span>
    <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">entryList</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fillInBlanks</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">blankLabel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">startTime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endTime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fills in the space between intervals with empty space</span>

<span class="sd">    This is necessary to do when saving to create a well-formed textgrid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">startTime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>

    <span class="k">if</span> <span class="n">endTime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>

    <span class="c1"># Special case: empty textgrid</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span><span class="p">,</span> <span class="n">blankLabel</span><span class="p">))</span>

    <span class="c1"># Create a new entry list</span>
    <span class="n">entryList</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">[:]</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">prevEnd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">newStart</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">newEnd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">prevEnd</span> <span class="o">&lt;</span> <span class="n">newStart</span><span class="p">:</span>
            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">prevEnd</span><span class="p">,</span> <span class="n">newStart</span><span class="p">,</span> <span class="n">blankLabel</span><span class="p">))</span>
        <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="n">prevEnd</span> <span class="o">=</span> <span class="n">newEnd</span>

    <span class="c1"># Special case: If there is a gap at the start of the file</span>
    <span class="k">assert</span> <span class="nb">float</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">startTime</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">startTime</span><span class="p">):</span>
        <span class="n">newEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">blankLabel</span><span class="p">))</span>

    <span class="c1"># Special case -- if there is a gap at the end of the file</span>
    <span class="k">if</span> <span class="n">endTime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">float</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">endTime</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">endTime</span><span class="p">):</span>
            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newEntryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">endTime</span><span class="p">,</span> <span class="n">blankLabel</span><span class="p">))</span>

    <span class="n">newEntryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_removeUltrashortIntervals</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">minLength</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove intervals that are very tiny</span>

<span class="sd">    Doing many small manipulations on intervals can lead to the creation</span>
<span class="sd">    of ultrashort intervals (e.g. 1*10^-15 seconds long).  This function</span>
<span class="sd">    removes such intervals.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First, remove tiny intervals</span>
    <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index to newEntryList</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">minLength</span><span class="p">:</span>
            <span class="c1"># Correct ultra-short entries</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lastStart</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">lastLabel</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lastStart</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">lastLabel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Special case: the first entry in oldEntryList was ultra-short</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">minTimestamp</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="c1"># Normal case</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Next, shift near equivalent tiny boundaries</span>
    <span class="c1"># This will link intervals that were connected by an interval</span>
    <span class="c1"># that was shorter than minLength</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">minLength</span><span class="p">:</span>
            <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">newEntryList</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">intervalOverlapCheck</span><span class="p">(</span>
    <span class="n">interval</span><span class="p">,</span> <span class="n">cmprInterval</span><span class="p">,</span> <span class="n">percentThreshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timeThreshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">boundaryInclusive</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether two intervals overlap</span>

<span class="sd">    Args:</span>
<span class="sd">        interval (Interval):</span>
<span class="sd">        cmprInterval (Interval):</span>
<span class="sd">        percentThreshold (float): if percentThreshold is greater than 0, then</span>
<span class="sd">            if the intervals overlap, they must overlap by at least this threshold</span>
<span class="sd">        timeThreshold (float): if greater than 0, then if the intervals overlap,</span>
<span class="sd">            they must overlap by at least this threshold</span>
<span class="sd">        boundaryInclusive (float): if true, then two intervals are considered to</span>
<span class="sd">            overlap if they share a boundary</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">cmprStartTime</span><span class="p">,</span> <span class="n">cmprEndTime</span> <span class="o">=</span> <span class="n">cmprInterval</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">overlapTime</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">endTime</span><span class="p">,</span> <span class="n">cmprEndTime</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">cmprStartTime</span><span class="p">))</span>
    <span class="n">overlapFlag</span> <span class="o">=</span> <span class="n">overlapTime</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Do they share a boundary?  Only need to check if one boundary ends</span>
    <span class="c1"># when another begins (because otherwise, they overlap in other ways)</span>
    <span class="n">boundaryOverlapFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">boundaryInclusive</span><span class="p">:</span>
        <span class="n">boundaryOverlapFlag</span> <span class="o">=</span> <span class="n">startTime</span> <span class="o">==</span> <span class="n">cmprEndTime</span> <span class="ow">or</span> <span class="n">endTime</span> <span class="o">==</span> <span class="n">cmprStartTime</span>

    <span class="c1"># Is the overlap over a certain percent?</span>
    <span class="n">percentOverlapFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">percentThreshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">overlapFlag</span><span class="p">:</span>
        <span class="n">totalTime</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">endTime</span><span class="p">,</span> <span class="n">cmprEndTime</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">cmprStartTime</span><span class="p">)</span>
        <span class="n">percentOverlap</span> <span class="o">=</span> <span class="n">overlapTime</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">totalTime</span><span class="p">)</span>

        <span class="n">percentOverlapFlag</span> <span class="o">=</span> <span class="n">percentOverlap</span> <span class="o">&gt;=</span> <span class="n">percentThreshold</span>

    <span class="c1"># Is the overlap more than a certain threshold?</span>
    <span class="n">timeOverlapFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">timeThreshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">overlapFlag</span><span class="p">:</span>
        <span class="n">timeOverlapFlag</span> <span class="o">=</span> <span class="n">overlapTime</span> <span class="o">&gt;</span> <span class="n">timeThreshold</span>

    <span class="n">overlapFlag</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">overlapFlag</span> <span class="ow">or</span> <span class="n">boundaryOverlapFlag</span> <span class="ow">or</span> <span class="n">percentOverlapFlag</span> <span class="ow">or</span> <span class="n">timeOverlapFlag</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">overlapFlag</span>


<span class="k">class</span> <span class="nc">TextgridCollisionException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tierName</span><span class="p">,</span> <span class="n">insertInterval</span><span class="p">,</span> <span class="n">collisionList</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TextgridCollisionException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierName</span> <span class="o">=</span> <span class="n">tierName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insertInterval</span> <span class="o">=</span> <span class="n">insertInterval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collisionList</span> <span class="o">=</span> <span class="n">collisionList</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dataTuple</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">insertInterval</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collisionList</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Attempted to insert interval </span><span class="si">%s</span><span class="s2"> into tier </span><span class="si">%s</span><span class="s2"> of textgrid&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;but overlapping entries </span><span class="si">%s</span><span class="s2"> already exist&quot;</span> <span class="o">%</span> <span class="n">dataTuple</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">TimelessTextgridTierException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;All textgrid tiers much have a min and max duration&quot;</span>


<span class="k">class</span> <span class="nc">BadIntervalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BadIntervalError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dataTuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Problem with interval--could not create textgrid &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">dataTuple</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">BadFormatException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectedFormat</span><span class="p">,</span> <span class="n">validFormatOptions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BadFormatException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selectedFormat</span> <span class="o">=</span> <span class="n">selectedFormat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validFormatOptions</span> <span class="o">=</span> <span class="n">validFormatOptions</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dataTuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selectedFormat</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validFormatOptions</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Problem with format.  Received </span><span class="si">%s</span><span class="s2"> but format must be one of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dataTuple</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">TextgridTier</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">tierType</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">entryType</span> <span class="o">=</span> <span class="n">Interval</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See PointTier or IntervalTier&quot;&quot;&quot;</span>
        <span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">=</span> <span class="n">entryList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxT</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">isEqual</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">)</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isEqual</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">selfEntry</span><span class="p">,</span> <span class="n">otherEntry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">selfSubEntry</span><span class="p">,</span> <span class="n">otherSubEntry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">selfEntry</span><span class="p">,</span> <span class="n">otherEntry</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="n">selfSubEntry</span><span class="p">,</span> <span class="n">otherSubEntry</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">selfSubEntry</span> <span class="o">==</span> <span class="n">otherSubEntry</span>

        <span class="k">return</span> <span class="n">isEqual</span>

    <span class="k">def</span> <span class="nf">appendTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a tier to the end of this one.</span>

<span class="sd">        This tier&#39;s maxtimestamp will be lengthened by the amount in the passed in tier.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">minTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">&lt;</span> <span class="n">minTime</span><span class="p">:</span>
            <span class="n">minTime</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="n">maxTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="n">appendTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierType</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span>

        <span class="n">entryList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">+</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an entry from the entryList&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchLabel</span><span class="p">,</span> <span class="n">substrMatchFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usingRE</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of all intervals that match the given label</span>

<span class="sd">        Args:</span>
<span class="sd">            matchLabel (str): the label to search for</span>
<span class="sd">            substrMatchFlag (bool): if True, match any label containing matchLabel. if False, label must be the same as matchLabel.</span>
<span class="sd">            usingRE (bool): if True, matchLabel is interpreted as a regular expression</span>

<span class="sd">        Returns:</span>
<span class="sd">            List: A list of indicies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">returnList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">usingRE</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="n">matchList</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">matchLabel</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">matchList</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">substrMatchFlag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">matchLabel</span><span class="p">:</span>
                        <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">matchLabel</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">returnList</span>

    <span class="k">def</span> <span class="nf">getAsText</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints each entry in the tier on a separate line w/ timing info</span>

<span class="sd">        TODO: Delete this?  It was being used in writing shortform textgrids</span>
<span class="sd">              but is not anymore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierType</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">),</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">[</span><span class="n">numToStr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unicode</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="nb">str</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="n">unicode</span>

            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">unicodeFunc</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">entryList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a new tier derived from the current one&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">entryList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entryList</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>
            <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">entry</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">pairedWav</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts the entries in the entryList&quot;&quot;&quot;</span>
        <span class="c1"># A list containing tuples and lists will be sorted with tuples</span>
        <span class="c1"># first and then lists.  To correctly sort, we need to make</span>
        <span class="c1"># sure that all data structures inside the entry list are</span>
        <span class="c1"># of the same data type.  The entry list is sorted whenever</span>
        <span class="c1"># the entry list is modified, so this is probably the best</span>
        <span class="c1"># place to enforce the data type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The given tier is set unioned to this tier.</span>

<span class="sd">        All entries in the given tier are added to the current tier.</span>
<span class="sd">        Overlapping entries are merged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTier</span><span class="o">.</span><span class="n">insertEntry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">)</span>

        <span class="n">retTier</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">retTier</span>


<span class="k">class</span> <span class="nc">PointTier</span><span class="p">(</span><span class="n">TextgridTier</span><span class="p">):</span>

    <span class="n">tierType</span> <span class="o">=</span> <span class="n">POINT_TIER</span>
    <span class="n">entryType</span> <span class="o">=</span> <span class="n">Point</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A point tier is for annotating instaneous events</span>

<span class="sd">        The entryList is of the form:</span>
<span class="sd">        [(timeVal1, label1), (timeVal2, label2), ]</span>

<span class="sd">        The data stored in the labels can be anything but will</span>
<span class="sd">        be interpreted as text by praatio (the label could be descriptive</span>
<span class="sd">        text e.g. (&#39;peak point here&#39;) or numerical data e.g. (pitch values</span>
<span class="sd">        like &#39;132&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>

        <span class="c1"># Determine the min and max timestamps</span>
        <span class="n">timeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span> <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">minT</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">maxT</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">_getWavDuration</span><span class="p">(</span><span class="n">pairedWav</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TimelessTextgridTierException</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PointTier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new tier containing all entries inside the new interval</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (str): Mode is ignored.  This parameter is kept for</span>
<span class="sd">                compatibility with IntervalTier.crop()</span>
<span class="sd">            rebaseToZero (bool): if True, all entries will have their</span>
<span class="sd">                timestamps subtracted by *cropStart*.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">timeV</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">timeV</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">]</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>

        <span class="k">return</span> <span class="n">PointTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (float):</span>
<span class="sd">            allowOvershoot (bool): if True, an interval can go beyond</span>
<span class="sd">                the bounds of the textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

            <span class="n">newTimestamp</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allowOvershoot</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">newTimestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
                <span class="k">assert</span> <span class="n">newTimestamp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

            <span class="k">if</span> <span class="n">newTimestamp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newTimestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="c1"># Determine new min and max timestamps</span>
        <span class="n">timeList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">subList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">]</span>
        <span class="n">newMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newMin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="k">if</span> <span class="n">newMax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">PointTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getValuesAtPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataTupleList</span><span class="p">,</span> <span class="n">fuzzyMatching</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values that occur at points in the point tier</span>

<span class="sd">        Args:</span>
<span class="sd">            dataTupleList (list):</span>
<span class="sd">            fuzzyMatching (bool): if True, if there is not a feature value</span>
<span class="sd">                at a point, the nearest feature value will be taken.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List</span>

<span class="sd">        The procedure assumes that all data is ordered in time.</span>
<span class="sd">        dataTupleList should be in the form</span>
<span class="sd">        [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]</span>

<span class="sd">        The procedure makes one pass through dataTupleList and one</span>
<span class="sd">        pass through self.entryList.  If the data is not sequentially</span>
<span class="sd">        ordered, the incorrect response will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">retList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">sortedDataTupleList</span> <span class="o">=</span> <span class="n">dataTupleList</span><span class="o">.</span><span class="n">sorted</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTuple</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getValueAtTime</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">,</span> <span class="n">sortedDataTupleList</span><span class="p">,</span> <span class="n">fuzzyMatching</span><span class="o">=</span><span class="n">fuzzyMatching</span><span class="p">,</span> <span class="n">startI</span><span class="o">=</span><span class="n">i</span>
            <span class="p">)</span>
            <span class="n">retTime</span><span class="p">,</span> <span class="n">retVal</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">retTuple</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">retTime</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">retVal</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">retList</span>

    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): the start of the deletion interval</span>
<span class="sd">            stop (float): the end of the deletion interval</span>
<span class="sd">            collisionCode (str): Ignored for the moment (added for compatibility with eraseRegion() for Interval Tiers)</span>
<span class="sd">            doShrink (bool): if True, moves leftward by (/stop/ - /start/) all points to the right of /stop/</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
        <span class="n">croppedTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">matchList</span> <span class="o">=</span> <span class="n">croppedTier</span><span class="o">.</span><span class="n">entryList</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Remove all the matches from the entryList</span>
            <span class="c1"># Go in reverse order because we&#39;re destructively altering</span>
            <span class="c1"># the order of the list (messes up index order)</span>
            <span class="k">for</span> <span class="n">tmpEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newTier</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">tmpEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

            <span class="n">newMax</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">-</span> <span class="n">diff</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">newMax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>

    <span class="k">def</span> <span class="nf">insertEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">warnFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inserts an interval into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (tuple|Point): the entry to insert</span>
<span class="sd">            warnFlag (bool): see below for details</span>
<span class="sd">            collisionCode (str): determines the behavior if intervals exist in</span>
<span class="sd">                the insertion area. One of (&#39;replace&#39;, &#39;merge&#39;, or None)</span>
<span class="sd">                - &#39;replace&#39;, existing items will be removed</span>
<span class="sd">                - &#39;merge&#39;, inserting item will be fused with existing items</span>
<span class="sd">                - None or any other value will thrown TextgridCollisionException</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        If warnFlag is True and collisionCode is not None, the user is notified</span>
<span class="sd">        of each collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">entry</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">searchEntry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">searchEntry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">matchList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">searchEntry</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
            <span class="n">oldEntry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">newEntry</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">oldEntry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TextgridCollisionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">matchList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warnFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Collision warning for </span><span class="si">%s</span><span class="s2"> with items </span><span class="si">%s</span><span class="s2"> of tier </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchList</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a region into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): the start time to insert a space at</span>
<span class="sd">            duration (float): the duration of the space to insert</span>
<span class="sd">            collisionCode (str): Ignored for the moment (added for compatibility with insertSpace() for Interval Tiers)</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>


<span class="k">class</span> <span class="nc">IntervalTier</span><span class="p">(</span><span class="n">TextgridTier</span><span class="p">):</span>

    <span class="n">tierType</span> <span class="o">=</span> <span class="n">INTERVAL_TIER</span>
    <span class="n">entryType</span> <span class="o">=</span> <span class="n">Interval</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An interval tier is for annotating events that have duration</span>

<span class="sd">        The entryList is of the form:</span>
<span class="sd">        [(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]</span>

<span class="sd">        The data stored in the labels can be anything but will</span>
<span class="sd">        be interpreted as text by praatio (the label could be descriptive</span>
<span class="sd">        text e.g. (&#39;erase this region&#39;) or numerical data e.g. (average pitch</span>
<span class="sd">        values like &#39;132&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxT</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">_getWavDuration</span><span class="p">(</span><span class="n">pairedWav</span><span class="p">)</span>

        <span class="c1"># Prevent poorly-formed textgrids from being created</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Anomaly: startTime=</span><span class="si">%f</span><span class="s2">, stopTime=</span><span class="si">%f</span><span class="s2">, label=</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
            <span class="k">assert</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Remove whitespace</span>
        <span class="n">tmpEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">:</span>
            <span class="n">tmpEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="n">tmpEntryList</span>

        <span class="c1"># Determine the minimum and maximum timestampes</span>
        <span class="n">minTimeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">subList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>
        <span class="n">maxTimeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">subList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minTimeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxTimeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxT</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minTimeList</span><span class="p">)</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxTimeList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TimelessTextgridTierException</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">IntervalTier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new tier with all entries that fit inside the new interval</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (string): one of [&#39;strict&#39;, &#39;lax&#39;, or &#39;truncated&#39;]</span>
<span class="sd">                - &#39;strict&#39;, only intervals wholly contained by the crop</span>
<span class="sd">                    interval will be kept</span>
<span class="sd">                - &#39;lax&#39;, partially contained intervals will be kept</span>
<span class="sd">                - &#39;truncated&#39;, partially contained intervals will be</span>
<span class="sd">                    truncated to fit within the crop region.</span>
<span class="sd">            rebaseToZero (bool): if True, the cropped textgrid values</span>
<span class="sd">                will be subtracted by the cropStart</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;strict&quot;</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>

        <span class="c1"># Debugging variables</span>
        <span class="n">cutTStart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cutTWithin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cutTEnd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">firstIntervalKeptProportion</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastIntervalKeptProportion</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">matchedEntry</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">intervalStart</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">intervalEnd</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">intervalLabel</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Don&#39;t need to investigate if the interval is before or after</span>
            <span class="c1"># the crop region</span>
            <span class="k">if</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropStart</span> <span class="ow">or</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Determine if the current subEntry is wholly contained</span>
            <span class="c1"># within the superEntry</span>
            <span class="k">if</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="c1"># If it is only partially contained within the superEntry AND</span>
            <span class="c1"># inclusion is &#39;lax&#39;, include it anyways</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lax&quot;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">or</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span>
            <span class="p">):</span>
                <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="c1"># If not strict, include partial tiers on the edges</span>
            <span class="c1"># -- regardless, record how much information was lost</span>
            <span class="c1">#        - for strict=True, the total time of the cut interval</span>
            <span class="c1">#        - for strict=False, the portion of the interval that lies</span>
            <span class="c1">#            outside the new interval</span>

            <span class="c1"># The current interval stradles the end of the new interval</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&gt;</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">cutTEnd</span> <span class="o">=</span> <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">cropEnd</span>
                <span class="n">lastIntervalKeptProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropEnd</span> <span class="o">-</span> <span class="n">intervalStart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervalStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="c1"># The current interval stradles the start of the new interval</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&lt;</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">cutTStart</span> <span class="o">=</span> <span class="n">cropStart</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="n">firstIntervalKeptProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">intervalEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="c1"># The current interval contains the new interval completely</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&lt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&gt;=</span> <span class="n">cropEnd</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lax&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="k">if</span> <span class="n">matchedEntry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matchedEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">startT</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">stopT</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">startT</span><span class="p">,</span> <span class="n">stopT</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newEntryList</span>
            <span class="p">]</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>

        <span class="c1"># Create subtier</span>
        <span class="n">croppedTier</span> <span class="o">=</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

        <span class="c1"># DEBUG info</span>
        <span class="c1">#         debugInfo = (subTier, cutTStart, cutTWithin, cutTEnd,</span>
        <span class="c1">#                      firstIntervalKeptProportion, lastIntervalKeptProportion)</span>

        <span class="k">return</span> <span class="n">croppedTier</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the set difference of this tier and the given one</span>

<span class="sd">        Any overlapping portions of entries with entries in this textgrid</span>
<span class="sd">        will be removed from the returned tier.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (IntervalTier):</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTier</span> <span class="o">=</span> <span class="n">retTier</span><span class="o">.</span><span class="n">eraseRegion</span><span class="p">(</span>
                <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">collisionCode</span><span class="o">=</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">retTier</span>

    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (start): the amount to shift all intervals</span>
<span class="sd">            allowOvershoot (bool): if True, an interval can</span>
<span class="sd">                go beyond the bounds of the textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

            <span class="n">newStart</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">start</span>
            <span class="n">newStop</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">stop</span>
            <span class="k">if</span> <span class="n">allowOvershoot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">newStart</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
                <span class="k">assert</span> <span class="n">newStop</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

            <span class="k">if</span> <span class="n">newStop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">newStart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newStart</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">newStart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newStart</span><span class="p">,</span> <span class="n">newStop</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="c1"># Determine new min and max timestamps</span>
        <span class="n">newMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">])</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">newMin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="k">if</span> <span class="n">newMax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            stop (float):</span>
<span class="sd">            collisionCode (bool): determines the behavior when the region to</span>
<span class="sd">                erase overlaps with existing intervals. One of [&#39;truncate&#39;,</span>
<span class="sd">                &#39;categorical&#39;, None]</span>
<span class="sd">                - &#39;truncate&#39; partially contained entries will have the portion</span>
<span class="sd">                    removed that overlaps with the target entry</span>
<span class="sd">                - &#39;categorical&#39; all entries that overlap, even partially, with</span>
<span class="sd">                    the target entry will be completely removed</span>
<span class="sd">                - None or any other value throws AssertionError</span>
<span class="sd">            doShrink (bool): if True, moves leftward by (/stop/ - /start/)</span>
<span class="sd">                amount, each item that occurs after /stop/</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="c1"># if the collisionCode is not properly set it isn&#39;t clear what to do</span>
        <span class="k">assert</span> <span class="n">collisionCode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="s2">&quot;categorical&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove all the matches from the entryList</span>
            <span class="c1"># Go in reverse order because we&#39;re destructively altering</span>
            <span class="c1"># the order of the list (messes up index order)</span>
            <span class="k">for</span> <span class="n">tmpEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newTier</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">tmpEntry</span><span class="p">)</span>

            <span class="c1"># If we&#39;re only truncating, reinsert entries on the left and</span>
            <span class="c1"># right edges</span>
            <span class="k">if</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;truncate&quot;</span><span class="p">:</span>

                <span class="c1"># Check left edge</span>
                <span class="k">if</span> <span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

                <span class="c1"># Check right edge</span>
                <span class="k">if</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

            <span class="c1"># Special case: an interval that spanned the deleted</span>
            <span class="c1"># section</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">rightEdge</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span>
                <span class="n">leftEdge</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span>
                <span class="n">sameLabel</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rightEdge</span> <span class="ow">and</span> <span class="n">leftEdge</span> <span class="ow">and</span> <span class="n">sameLabel</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>

                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newEntry</span><span class="p">)</span>

                    <span class="c1"># Only one interval can span the deleted section,</span>
                    <span class="c1"># so if we&#39;ve found it, move on</span>
                    <span class="k">break</span>

            <span class="n">newMax</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">-</span> <span class="n">diff</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">newMax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>

    <span class="k">def</span> <span class="nf">getValuesInIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataTupleList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns data from dataTupleList contained in labeled intervals</span>

<span class="sd">        dataTupleList should be of the form:</span>
<span class="sd">        [(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">returnList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">intervalDataList</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getValuesInInterval</span><span class="p">(</span>
                <span class="n">dataTupleList</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">interval</span><span class="p">,</span> <span class="n">intervalDataList</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">returnList</span>

    <span class="k">def</span> <span class="nf">getNonEntries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the regions of the textgrid without labels</span>

<span class="sd">        This can include unlabeled segments and regions marked as silent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">entryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Remove entries that have no duration (ie lie between two entries</span>
        <span class="c1"># that share a border)</span>
        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">invertedEntryList</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">invertedEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">invertedEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Interval</span><span class="p">)</span> <span class="k">else</span> <span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">invertedEntryList</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">invertedEntryList</span>

    <span class="k">def</span> <span class="nf">insertEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">warnFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inserts an interval into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (list|Interval): the Interval to insert</span>
<span class="sd">            warnFlag (bool):</span>
<span class="sd">            collisionCode: determines the behavior in the event that intervals</span>
<span class="sd">                exist in the insertion area.  One of [&#39;replace&#39;, &#39;merge&#39; None]</span>
<span class="sd">                - &#39;replace&#39; will remove existing items</span>
<span class="sd">                - &#39;merge&#39; will fuse the inserting item with existing items</span>
<span class="sd">                - None or any other value will throw a TextgridCollisionException</span>

<span class="sd">        if *warnFlag* is True and *collisionCode* is not None,</span>
<span class="sd">        the user is notified of each collision</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">entryList</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">matchEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">matchEntry</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">matchEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">matchEntry</span><span class="p">)</span>
            <span class="n">matchList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="n">matchList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># By starting time</span>

            <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
                <span class="nb">max</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
                <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">newEntry</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TextgridCollisionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">matchList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warnFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Collision warning for </span><span class="si">%s</span><span class="s2"> with items </span><span class="si">%s</span><span class="s2"> of tier </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchList</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a blank region into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            duration (float)</span>
<span class="sd">            collisionCode (str): determines the behavior that occurs if</span>
<span class="sd">                an interval stradles the starting pointone of [&#39;stretch&#39;,</span>
<span class="sd">                &#39;split&#39;, &#39;no change&#39;]</span>
<span class="sd">                - &#39;stretch&#39; stretches the interval by /duration/ amount</span>
<span class="sd">                - &#39;split&#39; splits the interval into two--everything to the</span>
<span class="sd">                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds</span>
<span class="sd">                - &#39;no change&#39; leaves the interval as is with no change</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the collisionCode is not properly set it isn&#39;t clear what to do</span>
        <span class="k">assert</span> <span class="n">collisionCode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stretch&quot;</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="s2">&quot;no change&quot;</span><span class="p">]</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="c1"># Entry exists before the insertion point</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="c1"># Entry exists after the insertion point</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="c1"># Entry straddles the insertion point</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;stretch&quot;</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;split&quot;</span><span class="p">:</span>
                    <span class="c1"># Left side of the split</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="c1"># Right side of the split</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                            <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">+</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span>
                            <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;no change&quot;</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the set intersection of this tier and the given one</span>

<span class="sd">        Only intervals that exist in both tiers will remain in the</span>
<span class="sd">        returned tier.  If intervals partially overlap, only the overlapping</span>
<span class="sd">        portion will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (IntervalTier): the tier to intersect with</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">subTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Combine the labels in the two tiers</span>
            <span class="n">stub</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%%</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="n">label</span>
            <span class="n">subEntryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">subEntry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subEntry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stub</span> <span class="o">%</span> <span class="n">subEntry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">subEntry</span> <span class="ow">in</span> <span class="n">subTier</span><span class="o">.</span><span class="n">entryList</span>
            <span class="p">]</span>

            <span class="n">retEntryList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subEntryList</span><span class="p">)</span>

        <span class="n">newName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newName</span><span class="p">,</span> <span class="n">retEntryList</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retTier</span>

    <span class="k">def</span> <span class="nf">morph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetTier</span><span class="p">,</span> <span class="n">filterFunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphs the duration of segments in this tier to those in another</span>

<span class="sd">        This preserves the labels and the duration of silence in</span>
<span class="sd">        this tier while changing the duration of labeled segments.</span>

<span class="sd">        Args:</span>
<span class="sd">            targetTier (IntervalTier):</span>
<span class="sd">            filterFunc (functor): if specified, filters entries. The</span>
<span class="sd">                functor takes one argument, an Interval. It returns true</span>
<span class="sd">                if the Interval should be modified and false if not.</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cumulativeAdjustAmount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastFromEnd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allPoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">,</span> <span class="n">targetTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">fromEntry</span><span class="p">,</span> <span class="n">targetEntry</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">safeZip</span><span class="p">(</span><span class="n">allPoints</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>

            <span class="n">fromStart</span><span class="p">,</span> <span class="n">fromEnd</span><span class="p">,</span> <span class="n">fromLabel</span> <span class="o">=</span> <span class="n">fromEntry</span>
            <span class="n">targetStart</span><span class="p">,</span> <span class="n">targetEnd</span> <span class="o">=</span> <span class="n">targetEntry</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># fromStart - lastFromEnd -&gt; was this interval and the</span>
            <span class="c1"># last one adjacent?</span>
            <span class="n">toStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">fromStart</span> <span class="o">-</span> <span class="n">lastFromEnd</span><span class="p">)</span> <span class="o">+</span> <span class="n">cumulativeAdjustAmount</span>

            <span class="n">currAdjustAmount</span> <span class="o">=</span> <span class="n">fromEnd</span> <span class="o">-</span> <span class="n">fromStart</span>
            <span class="k">if</span> <span class="n">filterFunc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filterFunc</span><span class="p">(</span><span class="n">fromLabel</span><span class="p">):</span>
                <span class="n">currAdjustAmount</span> <span class="o">=</span> <span class="n">targetEnd</span> <span class="o">-</span> <span class="n">targetStart</span>

            <span class="n">toEnd</span> <span class="o">=</span> <span class="n">cumulativeAdjustAmount</span> <span class="o">=</span> <span class="n">toStart</span> <span class="o">+</span> <span class="n">currAdjustAmount</span>
            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">toStart</span><span class="p">,</span> <span class="n">toEnd</span><span class="p">,</span> <span class="n">fromLabel</span><span class="p">))</span>

            <span class="n">lastFromEnd</span> <span class="o">=</span> <span class="n">fromEnd</span>

        <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">cumulativeDifference</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">cumulativeDifference</span>

        <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Textgrid</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;A container that stores and operates over interval and point tiers&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Preserves the order of the tiers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">isEqual</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">)</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>

        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tierNameList</span>
        <span class="k">if</span> <span class="n">isEqual</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">isEqual</span>

    <span class="k">def</span> <span class="nf">addTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">tierIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a tier to this textgrid.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (TextgridTier):</span>
<span class="sd">            tierIndex (int): if specified, insert the tier into the specified position</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">tierIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">tierIndex</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tier</span>

        <span class="n">minV</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">minV</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minV</span>

        <span class="n">maxV</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">maxV</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxV</span>

    <span class="k">def</span> <span class="nf">appendTextgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">onlyMatchingNames</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append one textgrid to the end of this one</span>

<span class="sd">        Args:</span>
<span class="sd">            tg (Textgrid): the tier to add to this one</span>
<span class="sd">            onlyMatchingNames (bool): if False, tiers that don&#39;t appear in both</span>
<span class="sd">                textgrids will also appear</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="n">minTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">maxTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="c1"># Get all tier names.  Ordered first by this textgrid and</span>
        <span class="c1"># then by the other textgrid.</span>
        <span class="n">combinedTierNameList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">combinedTierNameList</span><span class="p">:</span>
                <span class="n">combinedTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Determine the tier names that will be in the final textgrid</span>
        <span class="n">finalTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">onlyMatchingNames</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">finalTierNameList</span> <span class="o">=</span> <span class="n">combinedTierNameList</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">combinedTierNameList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                        <span class="n">finalTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Add tiers from this textgrid</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">finalTierNameList</span><span class="p">:</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                <span class="n">retTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="c1"># Add tiers from the given textgrid</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">finalTierNameList</span><span class="p">:</span>
                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">)</span>

                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                    <span class="n">newEntryList</span> <span class="o">=</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span><span class="o">.</span><span class="n">entryList</span>
                    <span class="n">newEntryList</span> <span class="o">+=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">entryList</span>

                    <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
                        <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span>
                        <span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span>
                        <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">retTG</span><span class="o">.</span><span class="n">replaceTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">appendTier</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">)</span>
                    <span class="n">retTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retTG</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a textgrid where all intervals fit within the crop region</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (str): one of [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;]</span>
<span class="sd">                - &#39;strict&#39;, only intervals wholly contained by the crop</span>
<span class="sd">                    interval will be kept</span>
<span class="sd">                - &#39;lax&#39;, partially contained intervals will be kept</span>
<span class="sd">                - &#39;truncated&#39;, partially contained intervals will be</span>
<span class="sd">                    truncated to fit within the crop region.</span>
<span class="sd">            rebaseToZero (bool): if True, the cropped textgrid values will be</span>
<span class="sd">                subtracted by the cropStart</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;strict&quot;</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minT</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxT</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTG</span>

    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            stop (float):</span>
<span class="sd">            doShrink (bool): if True, all entries appearing after the</span>
<span class="sd">                erased interval will be shifted to fill the void (ie</span>
<span class="sd">                the duration of the textgrid will be reduced by</span>
<span class="sd">                *start* - *stop*)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

        <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">maxTimestamp</span> <span class="o">-=</span> <span class="n">diff</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">eraseRegion</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="n">doShrink</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">newTG</span>

    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (float): the amount to offset in seconds</span>
<span class="sd">            allowOvershoot (bool): if True, entries can go</span>
<span class="sd">                beyond the min and max timestamp set by the</span>
<span class="sd">                Textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="p">)</span>

            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tg</span>

    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a blank region into a textgrid</span>

<span class="sd">        Every item that occurs after *start* will be pushed back by</span>
<span class="sd">        *duration* seconds</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            duration (float):</span>
<span class="sd">            collisionCode (str): Determines behaviour in the event that an</span>
<span class="sd">                interval stradles the starting point.</span>
<span class="sd">                One of [&#39;stretch&#39;, &#39;split&#39;, &#39;no change&#39;, None]</span>
<span class="sd">                - &#39;stretch&#39; stretches the interval by /duration/ amount</span>
<span class="sd">                - &#39;split&#39; splits the interval into two--everything to the</span>
<span class="sd">                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds</span>
<span class="sd">                - &#39;no change&#39; leaves the interval as is with no change</span>
<span class="sd">                - None or any other value throws an AssertionError</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>

        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">insertSpace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTG</span>

    <span class="k">def</span> <span class="nf">mergeTiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includeFunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tierList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preserveOtherTiers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine tiers</span>

<span class="sd">        Args:</span>
<span class="sd">            includeFunc (functor): regulates which intervals to include in the</span>
<span class="sd">                merging with all others being tossed (default accepts all)</span>
<span class="sd">            tierList (list): A list of tier names to combine. If none, combine</span>
<span class="sd">                all tiers.</span>
<span class="sd">            preserveOtherTiers (bool): If false, uncombined tiers are not</span>
<span class="sd">                included in the output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tierList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tierList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span>

        <span class="k">if</span> <span class="n">includeFunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">includeFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">entryList</span><span class="p">:</span> <span class="kc">True</span>

        <span class="c1"># Determine the tiers to merge</span>
        <span class="n">intervalTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pointTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tierList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">IntervalTier</span><span class="p">):</span>
                <span class="n">intervalTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">PointTier</span><span class="p">):</span>
                <span class="n">pointTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Merge the interval tiers</span>
        <span class="n">intervalTier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervalTierNameList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">intervalTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">intervalTierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">intervalTierNameList</span><span class="p">:</span>
            <span class="n">intervalTier</span> <span class="o">=</span> <span class="n">intervalTier</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">])</span>

        <span class="c1"># Merge the point tiers</span>
        <span class="n">pointTier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointTierNameList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pointTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">pointTierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">pointTierNameList</span><span class="p">:</span>
            <span class="n">pointTier</span> <span class="o">=</span> <span class="n">pointTier</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">])</span>

        <span class="c1"># Create the final textgrid to output</span>
        <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">intervalTier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">intervalTier</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pointTier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">pointTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tg</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of this Textgrid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">renameTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldName</span><span class="p">,</span> <span class="n">newName</span><span class="p">):</span>
        <span class="n">oldTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">oldName</span><span class="p">]</span>
        <span class="n">tierIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">oldName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeTier</span><span class="p">(</span><span class="n">oldName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">oldTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newName</span><span class="p">,</span> <span class="n">oldTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span> <span class="n">tierIndex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removeTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replaceTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newTier</span><span class="p">):</span>
        <span class="n">tierIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeTier</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">,</span> <span class="n">tierIndex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">,</span>
        <span class="n">minimumIntervalLength</span><span class="o">=</span><span class="n">MIN_INTERVAL_LENGTH</span><span class="p">,</span>
        <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">useShortForm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">outputFormat</span><span class="o">=</span><span class="n">TEXTGRID</span><span class="p">,</span>
        <span class="n">ignoreBlankSpaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To save the current textgrid</span>

<span class="sd">        Args:</span>
<span class="sd">            fn (str): the fullpath filename of the output</span>
<span class="sd">            minimumIntervalLength (float): any labeled intervals smaller</span>
<span class="sd">                than this will be removed, useful for removing ultrashort</span>
<span class="sd">                or fragmented intervals; if None, don&#39;t remove any.</span>
<span class="sd">                Removed intervals are merged (without their label) into</span>
<span class="sd">                adjacent entries.</span>
<span class="sd">            minTimestamp (float): the minTimestamp of the saved Textgrid;</span>
<span class="sd">                if None, use whatever is defined in the Textgrid object.</span>
<span class="sd">                If minTimestamp is larger than timestamps in your textgrid,</span>
<span class="sd">                an exception will be thrown.</span>
<span class="sd">            maxTimestamp (float): the maxTimestamp of the saved Textgrid;</span>
<span class="sd">                if None, use whatever is defined in the Textgrid object.</span>
<span class="sd">                If maxTimestamp is smaller than timestamps in your textgrid,</span>
<span class="sd">                an exception will be thrown.</span>
<span class="sd">            useShortForm (bool): if True, save the textgrid as a short</span>
<span class="sd">                textgrid. Otherwise, use the long-form textgrid format.</span>
<span class="sd">                For backwards compatibility, is True by default. Ignored if</span>
<span class="sd">                format is not &#39;Textgrid&#39;</span>
<span class="sd">            outputFormat (str): one of [&#39;textgrid&#39;, &#39;json&#39;]</span>
<span class="sd">            ignoreBlankSpaces (bool): if False, blank sections in interval</span>
<span class="sd">                tiers will be filled in with an empty interval</span>
<span class="sd">                (with a label of &quot;&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">outputFormat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_OUTPUT_FORMATS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BadFormatException</span><span class="p">(</span><span class="n">outputFormat</span><span class="p">,</span> <span class="n">SUPPORTED_OUTPUT_FORMATS</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outputFormat</span> <span class="o">==</span> <span class="n">TEXTGRID</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">useShortForm</span><span class="p">:</span>
                <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToShortTextForm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">minimumIntervalLength</span><span class="p">,</span>
                    <span class="n">minTimestamp</span><span class="p">,</span>
                    <span class="n">maxTimestamp</span><span class="p">,</span>
                    <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToLongTextForm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">minimumIntervalLength</span><span class="p">,</span>
                    <span class="n">minTimestamp</span><span class="p">,</span>
                    <span class="n">maxTimestamp</span><span class="p">,</span>
                    <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">outputFormat</span> <span class="o">==</span> <span class="n">JSON</span><span class="p">:</span>
            <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToJson</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">minimumIntervalLength</span><span class="p">,</span>
                <span class="n">minTimestamp</span><span class="p">,</span>
                <span class="n">maxTimestamp</span><span class="p">,</span>
                <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outputTxt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_prepTgForSaving</span><span class="p">(</span>
    <span class="n">tg</span><span class="p">,</span> <span class="n">minimumIntervalLength</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">ignoreBlankSpaces</span>
<span class="p">):</span>
    <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">tier</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">minTimestamp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tg</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minTimestamp</span>

    <span class="k">if</span> <span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxTimestamp</span>

    <span class="c1"># Fill in the blank spaces for interval tiers</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignoreBlankSpaces</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">IntervalTier</span><span class="p">):</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="n">_fillInBlanks</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">minimumIntervalLength</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">_removeUltrashortIntervals</span><span class="p">(</span>
                        <span class="n">tier</span><span class="p">,</span> <span class="n">minimumIntervalLength</span><span class="p">,</span> <span class="n">minTimestamp</span>
                    <span class="p">)</span>
                <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tier</span>

    <span class="k">for</span> <span class="n">tier</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">tier</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">tg</span>


<span class="k">def</span> <span class="nf">_tgToShortTextForm</span><span class="p">(</span>
    <span class="n">tg</span><span class="p">,</span>
    <span class="n">minimumIntervalLength</span><span class="o">=</span><span class="n">MIN_INTERVAL_LENGTH</span><span class="p">,</span>
    <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ignoreBlankSpaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">_prepTgForSaving</span><span class="p">(</span>
        <span class="n">tg</span><span class="p">,</span> <span class="n">minimumIntervalLength</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">ignoreBlankSpaces</span>
    <span class="p">)</span>

    <span class="c1"># Header</span>
    <span class="n">outputTxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s1">&#39;File type = &quot;ooTextFile&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s1">&#39;Object class = &quot;TextGrid&quot;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">numToStr</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">),</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">))</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;&lt;exists&gt;</span><span class="se">\n</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
        <span class="n">tier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">_escapeQuotes</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">),</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">[</span><span class="n">numToStr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">_escapeQuotes</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unicode</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="nb">str</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="n">unicode</span>

            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">unicodeFunc</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">text</span>

    <span class="k">return</span> <span class="n">outputTxt</span>


<span class="k">def</span> <span class="nf">_tgToLongTextForm</span><span class="p">(</span>
    <span class="n">tg</span><span class="p">,</span>
    <span class="n">minimumIntervalLength</span><span class="o">=</span><span class="n">MIN_INTERVAL_LENGTH</span><span class="p">,</span>
    <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ignoreBlankSpaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">_prepTgForSaving</span><span class="p">(</span>
        <span class="n">tg</span><span class="p">,</span> <span class="n">minimumIntervalLength</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">ignoreBlankSpaces</span>
    <span class="p">)</span>
    <span class="n">outputTxt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s1">&#39;File type = &quot;ooTextFile&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s1">&#39;Object class = &quot;TextGrid&quot;</span><span class="se">\n\n</span><span class="s1">&#39;</span>

    <span class="n">tab</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">4</span>

    <span class="c1"># Header</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;xmin = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">)</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;xmax = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;tiers? &lt;exists&gt; </span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;size = </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">)</span>
    <span class="n">outputTxt</span> <span class="o">+=</span> <span class="s2">&quot;item []: </span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">for</span> <span class="n">tierNum</span><span class="p">,</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">):</span>
        <span class="n">tier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
        <span class="c1"># Interval header</span>
        <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">+</span> <span class="s2">&quot;item [</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tierNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s1">&#39;class = &quot;</span><span class="si">%s</span><span class="s1">&quot; </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span>
        <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s1">&#39;name = &quot;</span><span class="si">%s</span><span class="s1">&quot; </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">_escapeQuotes</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>
        <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;xmin = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">)</span>
        <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;xmax = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span> <span class="o">==</span> <span class="n">INTERVAL_TIER</span><span class="p">:</span>
            <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;intervals: size = </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">intervalNum</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;intervals [</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">intervalNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s2">&quot;xmin = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s2">&quot;xmax = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;text = &quot;</span><span class="si">%s</span><span class="s1">&quot; </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">_escapeQuotes</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;points: size = </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pointNum</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;points [</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pointNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s2">&quot;number = </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">numToStr</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
                <span class="n">outputTxt</span> <span class="o">+=</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;mark = &quot;</span><span class="si">%s</span><span class="s1">&quot; </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">_escapeQuotes</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outputTxt</span>


<span class="k">def</span> <span class="nf">_tgToJson</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">minimumIntervalLength</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">ignoreBlankSpaces</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a json representation of a textgrid&quot;&quot;&quot;</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">_prepTgForSaving</span><span class="p">(</span>
        <span class="n">tg</span><span class="p">,</span> <span class="n">minimumIntervalLength</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">ignoreBlankSpaces</span>
    <span class="p">)</span>
    <span class="n">tgAsDict</span> <span class="o">=</span> <span class="n">_tgToDictionary</span><span class="p">(</span><span class="n">tg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">tgAsDict</span><span class="p">,</span> <span class="n">ensure_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tgToDictionary</span><span class="p">(</span><span class="n">tg</span><span class="p">):</span>
    <span class="n">tiers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
        <span class="n">tier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
        <span class="n">tierDict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">tierName</span><span class="p">,</span>
            <span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span>
            <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span>
            <span class="s2">&quot;entries&quot;</span><span class="p">:</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">tiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierDict</span><span class="p">)</span>

    <span class="n">tgAsDict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="n">tg</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="s2">&quot;tiers&quot;</span><span class="p">:</span> <span class="n">tiers</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">tgAsDict</span>


<span class="k">def</span> <span class="nf">_dictionaryToTg</span><span class="p">(</span><span class="n">tgAsDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts a dictionary representation of a textgrid to a Textgrid&quot;&quot;&quot;</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
    <span class="n">tg</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">tgAsDict</span><span class="p">[</span><span class="s2">&quot;xmin&quot;</span><span class="p">]</span>
    <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">tgAsDict</span><span class="p">[</span><span class="s2">&quot;xmax&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">tierAsDict</span> <span class="ow">in</span> <span class="n">tgAsDict</span><span class="p">[</span><span class="s2">&quot;tiers&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">tierAsDict</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">INTERVAL_TIER</span><span class="p">:</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">IntervalTier</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">PointTier</span>
        <span class="n">tier</span> <span class="o">=</span> <span class="n">klass</span><span class="p">(</span>
            <span class="n">tierAsDict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="n">tierAsDict</span><span class="p">[</span><span class="s2">&quot;entries&quot;</span><span class="p">],</span>
            <span class="n">tierAsDict</span><span class="p">[</span><span class="s2">&quot;xmin&quot;</span><span class="p">],</span>
            <span class="n">tierAsDict</span><span class="p">[</span><span class="s2">&quot;xmax&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tg</span>


<span class="k">def</span> <span class="nf">openTextgrid</span><span class="p">(</span><span class="n">fnFullPath</span><span class="p">,</span> <span class="n">readRaw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">readAsJson</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Opens a textgrid for editing</span>

<span class="sd">    Args:</span>
<span class="sd">        fnFullPath (str): the path to the textgrid to open</span>
<span class="sd">        readRaw (bool): points and intervals with an empty label</span>
<span class="sd">            &#39;&#39; are removed unless readRaw=True</span>
<span class="sd">        readAsJson (bool): if True, assume the Textgrid is saved</span>
<span class="sd">            as Json rather than in its native format</span>

<span class="sd">    Returns:</span>
<span class="sd">        Textgrid</span>

<span class="sd">    https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fnFullPath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-16&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fnFullPath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">readAsJson</span><span class="p">:</span>
        <span class="n">tgAsDict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">textgrid</span> <span class="o">=</span> <span class="n">_dictionaryToTg</span><span class="p">(</span><span class="n">tgAsDict</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">caseA</span> <span class="o">=</span> <span class="s2">&quot;ooTextFile short&quot;</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="n">caseB</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;item ?\[&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">caseA</span> <span class="ow">or</span> <span class="n">caseB</span><span class="p">:</span>
            <span class="n">textgrid</span> <span class="o">=</span> <span class="n">_parseShortTextgrid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">textgrid</span> <span class="o">=</span> <span class="n">_parseNormalTextgrid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">readRaw</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">textgrid</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">textgrid</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">_removeBlanks</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>
            <span class="n">textgrid</span><span class="o">.</span><span class="n">replaceTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">textgrid</span>


<span class="k">def</span> <span class="nf">_parseNormalTextgrid</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a normal textgrid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

    <span class="c1"># Toss textgrid header</span>
    <span class="n">header</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;item ?\[&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

    <span class="n">headerList</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">tgMin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">headerList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="n">tgMax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">headerList</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

    <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">tgMin</span>
    <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">tgMax</span>

    <span class="c1"># Process each tier individually (will be output to separate folders)</span>
    <span class="n">tierList</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;item ?\[&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">tierTxt</span> <span class="ow">in</span> <span class="n">tierList</span><span class="p">:</span>

        <span class="n">hasData</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s1">&#39;class = &quot;IntervalTier&quot;&#39;</span> <span class="ow">in</span> <span class="n">tierTxt</span><span class="p">:</span>
            <span class="n">tierType</span> <span class="o">=</span> <span class="n">INTERVAL_TIER</span>
            <span class="n">searchWord</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;intervals ?\[&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tierType</span> <span class="o">=</span> <span class="n">POINT_TIER</span>
            <span class="n">searchWord</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;points ?\[&quot;</span>

        <span class="c1"># Get tier meta-information</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">searchWord</span><span class="p">,</span> <span class="n">tierTxt</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">tierData</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># A tier with no entries</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;size ?= ?0&quot;</span><span class="p">,</span> <span class="n">tierTxt</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">tierTxt</span>
                <span class="n">tierData</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">hadData</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="n">tierName</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;name ?= ?</span><span class="se">\&quot;</span><span class="s2">(.*)</span><span class="se">\&quot;</span><span class="s2">\s*$&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tierName</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">tierName</span><span class="p">)</span>

        <span class="n">tierStart</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xmin ?= ?([\d.]+)\s*$&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tierStart</span> <span class="o">=</span> <span class="n">strToIntOrFloat</span><span class="p">(</span><span class="n">tierStart</span><span class="p">)</span>

        <span class="n">tierEnd</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xmax ?= ?([\d.]+)\s*$&quot;</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tierEnd</span> <span class="o">=</span> <span class="n">strToIntOrFloat</span><span class="p">(</span><span class="n">tierEnd</span><span class="p">)</span>

        <span class="c1"># Get the tier entry list</span>
        <span class="n">tierEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labelI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">tierType</span> <span class="o">==</span> <span class="n">INTERVAL_TIER</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">tierData</span><span class="p">:</span>
                <span class="n">timeStart</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xmin ?= ?([\d.]+)\s*$&quot;</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">timeEnd</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xmax ?= ?([\d.]+)\s*$&quot;</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;text ?= ?</span><span class="se">\&quot;</span><span class="s2">(.*)</span><span class="se">\&quot;</span><span class="s2">\s*$&quot;</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">tierEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timeStart</span><span class="p">,</span> <span class="n">timeEnd</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tierEntryList</span><span class="p">,</span> <span class="n">tierStart</span><span class="p">,</span> <span class="n">tierEnd</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">tierData</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;number ?= ?([\d.]+)\s*$&quot;</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;mark ?= ?</span><span class="se">\&quot;</span><span class="s2">(.*)</span><span class="se">\&quot;</span><span class="s2">\s*$&quot;</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">tierEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">PointTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tierEntryList</span><span class="p">,</span> <span class="n">tierStart</span><span class="p">,</span> <span class="n">tierEnd</span><span class="p">)</span>

        <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newTG</span>


<span class="k">def</span> <span class="nf">_parseShortTextgrid</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a short textgrid file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

    <span class="n">intervalIndicies</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">findAll</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;&quot;IntervalTier&quot;&#39;</span><span class="p">)]</span>
    <span class="n">pointIndicies</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">findAll</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;&quot;TextTier&quot;&#39;</span><span class="p">)]</span>

    <span class="n">indexList</span> <span class="o">=</span> <span class="n">intervalIndicies</span> <span class="o">+</span> <span class="n">pointIndicies</span>
    <span class="n">indexList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="kc">None</span><span class="p">))</span>  <span class="c1"># The &#39;end&#39; of the file</span>
    <span class="n">indexList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">tupleList</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">indexList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indexList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indexList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Set the textgrid&#39;s min and max times</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span> <span class="n">tupleList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">headerList</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">tgMin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">headerList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="n">tgMax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">headerList</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

    <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">tgMin</span>
    <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">tgMax</span>

    <span class="c1"># Load the data for each tier</span>
    <span class="k">for</span> <span class="n">blockStartI</span><span class="p">,</span> <span class="n">blockEndI</span><span class="p">,</span> <span class="n">isInterval</span> <span class="ow">in</span> <span class="n">tupleList</span><span class="p">:</span>
        <span class="n">tierData</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">blockStartI</span><span class="p">:</span><span class="n">blockEndI</span><span class="p">]</span>

        <span class="c1"># First row contains the tier type, which we already know</span>
        <span class="n">metaStartI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Tier meta-information</span>
        <span class="n">tierName</span><span class="p">,</span> <span class="n">tierNameEndI</span> <span class="o">=</span> <span class="n">_fetchTextRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">metaStartI</span><span class="p">)</span>
        <span class="n">tierStartTime</span><span class="p">,</span> <span class="n">tierStartTimeI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">tierNameEndI</span><span class="p">)</span>
        <span class="n">tierEndTime</span><span class="p">,</span> <span class="n">tierEndTimeI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">tierStartTimeI</span><span class="p">)</span>
        <span class="n">startTimeI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">tierEndTimeI</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">tierStartTime</span> <span class="o">=</span> <span class="n">strToIntOrFloat</span><span class="p">(</span><span class="n">tierStartTime</span><span class="p">)</span>
        <span class="n">tierEndTime</span> <span class="o">=</span> <span class="n">strToIntOrFloat</span><span class="p">(</span><span class="n">tierEndTime</span><span class="p">)</span>

        <span class="c1"># Tier entry data</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">isInterval</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">startTime</span><span class="p">,</span> <span class="n">endTimeI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">startTimeI</span><span class="p">)</span>
                    <span class="n">endTime</span><span class="p">,</span> <span class="n">labelI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">endTimeI</span><span class="p">)</span>
                    <span class="n">label</span><span class="p">,</span> <span class="n">startTimeI</span> <span class="o">=</span> <span class="n">_fetchTextRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">labelI</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">IntervalTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">tierStartTime</span><span class="p">,</span> <span class="n">tierEndTime</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">time</span><span class="p">,</span> <span class="n">labelI</span> <span class="o">=</span> <span class="n">_fetchRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">startTimeI</span><span class="p">)</span>
                    <span class="n">label</span><span class="p">,</span> <span class="n">startTimeI</span> <span class="o">=</span> <span class="n">_fetchTextRow</span><span class="p">(</span><span class="n">tierData</span><span class="p">,</span> <span class="n">labelI</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">PointTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">tierStartTime</span><span class="p">,</span> <span class="n">tierEndTime</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">newTG</span>


<span class="k">def</span> <span class="nf">numToStr</span><span class="p">(</span><span class="n">inputNum</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_isclose</span><span class="p">(</span><span class="n">inputNum</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">inputNum</span><span class="p">)):</span>
        <span class="n">retVal</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">inputNum</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">retVal</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">inputNum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">retVal</span>


<span class="k">def</span> <span class="nf">strToIntOrFloat</span><span class="p">(</span><span class="n">inputStr</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">inputStr</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">inputStr</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">inputStr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fetchRow</span><span class="p">(</span><span class="n">dataStr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">searchStr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">searchStr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">startIndex</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">startIndex</span> <span class="o">=</span> <span class="n">dataStr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">searchStr</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">searchStr</span><span class="p">)</span>

    <span class="n">endIndex</span> <span class="o">=</span> <span class="n">dataStr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">)</span>

    <span class="n">word</span> <span class="o">=</span> <span class="n">dataStr</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:</span><span class="n">endIndex</span><span class="p">]</span>
    <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span> <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">word</span><span class="p">,</span> <span class="n">endIndex</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_fetchTextRow</span><span class="p">(</span><span class="n">dataStr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">searchStr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">searchStr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">startIndex</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">startIndex</span> <span class="o">=</span> <span class="n">dataStr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">searchStr</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">searchStr</span><span class="p">)</span>

    <span class="c1"># A textgrid text is ended by double quotes. Double quotes that</span>
    <span class="c1"># appear in the text are escaped by a preceeding double quotes.</span>
    <span class="c1"># We know we&#39;re at the end of a text if the number of double</span>
    <span class="c1"># quotes is odd.</span>
    <span class="n">endIndex</span> <span class="o">=</span> <span class="n">startIndex</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">quoteStartIndex</span> <span class="o">=</span> <span class="n">dataStr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">)</span>
        <span class="n">quoteEndIndex</span> <span class="o">=</span> <span class="n">quoteStartIndex</span>
        <span class="k">while</span> <span class="n">dataStr</span><span class="p">[</span><span class="n">quoteEndIndex</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="n">quoteEndIndex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">endIndex</span> <span class="o">=</span> <span class="n">quoteEndIndex</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">quoteEndIndex</span> <span class="o">-</span> <span class="n">quoteStartIndex</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">word</span> <span class="o">=</span> <span class="n">dataStr</span><span class="p">[</span><span class="n">startIndex</span><span class="p">:</span><span class="n">endIndex</span><span class="p">]</span>
    <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Remove the quote marks around the text</span>
    <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>  <span class="c1"># Unescape quote marks</span>

    <span class="c1"># Advance to the end of the line</span>
    <span class="n">endIndex</span> <span class="o">=</span> <span class="n">dataStr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">word</span><span class="p">,</span> <span class="n">endIndex</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

        </details>

            </section>
                <section id="Interval">
                                <div class="attr class">
        <a class="headerlink" href="#Interval">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Interval</span>(<span class="base">builtins.tuple</span>):
    </div>

        
            <div class="docstring"><p>Interval(start, end, label)</p>
</div>


                            <div id="Interval.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Interval.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Interval</span><span class="signature">(start, end, label)</span>
    </div>

        
            <div class="docstring"><p>Create new instance of Interval(start, end, label)</p>
</div>


                            </div>
                            <div id="Interval.start" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Interval.start">#&nbsp;&nbsp</a>

        <span class="name">start</span>
    </div>

            <div class="docstring"><p>Alias for field number 0</p>
</div>


                            </div>
                            <div id="Interval.end" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Interval.end">#&nbsp;&nbsp</a>

        <span class="name">end</span>
    </div>

            <div class="docstring"><p>Alias for field number 1</p>
</div>


                            </div>
                            <div id="Interval.label" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Interval.label">#&nbsp;&nbsp</a>

        <span class="name">label</span>
    </div>

            <div class="docstring"><p>Alias for field number 2</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.tuple</dt>
                                <dd id="Interval.index" class="function">index</dd>
                <dd id="Interval.count" class="function">count</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Point">
                                <div class="attr class">
        <a class="headerlink" href="#Point">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Point</span>(<span class="base">builtins.tuple</span>):
    </div>

        
            <div class="docstring"><p>Point(time, label)</p>
</div>


                            <div id="Point.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Point.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Point</span><span class="signature">(time, label)</span>
    </div>

        
            <div class="docstring"><p>Create new instance of Point(time, label)</p>
</div>


                            </div>
                            <div id="Point.time" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Point.time">#&nbsp;&nbsp</a>

        <span class="name">time</span>
    </div>

            <div class="docstring"><p>Alias for field number 0</p>
</div>


                            </div>
                            <div id="Point.label" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Point.label">#&nbsp;&nbsp</a>

        <span class="name">label</span>
    </div>

            <div class="docstring"><p>Alias for field number 1</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.tuple</dt>
                                <dd id="Point.index" class="function">index</dd>
                <dd id="Point.count" class="function">count</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="intervalOverlapCheck">
                            <div class="attr function"><a class="headerlink" href="#intervalOverlapCheck">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">intervalOverlapCheck</span><span class="signature">(
    interval,
    cmprInterval,
    percentThreshold=0,
    timeThreshold=0,
    boundaryInclusive=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">intervalOverlapCheck</span><span class="p">(</span>
    <span class="n">interval</span><span class="p">,</span> <span class="n">cmprInterval</span><span class="p">,</span> <span class="n">percentThreshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timeThreshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">boundaryInclusive</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether two intervals overlap</span>

<span class="sd">    Args:</span>
<span class="sd">        interval (Interval):</span>
<span class="sd">        cmprInterval (Interval):</span>
<span class="sd">        percentThreshold (float): if percentThreshold is greater than 0, then</span>
<span class="sd">            if the intervals overlap, they must overlap by at least this threshold</span>
<span class="sd">        timeThreshold (float): if greater than 0, then if the intervals overlap,</span>
<span class="sd">            they must overlap by at least this threshold</span>
<span class="sd">        boundaryInclusive (float): if true, then two intervals are considered to</span>
<span class="sd">            overlap if they share a boundary</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">cmprStartTime</span><span class="p">,</span> <span class="n">cmprEndTime</span> <span class="o">=</span> <span class="n">cmprInterval</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">overlapTime</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">endTime</span><span class="p">,</span> <span class="n">cmprEndTime</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">cmprStartTime</span><span class="p">))</span>
    <span class="n">overlapFlag</span> <span class="o">=</span> <span class="n">overlapTime</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Do they share a boundary?  Only need to check if one boundary ends</span>
    <span class="c1"># when another begins (because otherwise, they overlap in other ways)</span>
    <span class="n">boundaryOverlapFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">boundaryInclusive</span><span class="p">:</span>
        <span class="n">boundaryOverlapFlag</span> <span class="o">=</span> <span class="n">startTime</span> <span class="o">==</span> <span class="n">cmprEndTime</span> <span class="ow">or</span> <span class="n">endTime</span> <span class="o">==</span> <span class="n">cmprStartTime</span>

    <span class="c1"># Is the overlap over a certain percent?</span>
    <span class="n">percentOverlapFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">percentThreshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">overlapFlag</span><span class="p">:</span>
        <span class="n">totalTime</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">endTime</span><span class="p">,</span> <span class="n">cmprEndTime</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">cmprStartTime</span><span class="p">)</span>
        <span class="n">percentOverlap</span> <span class="o">=</span> <span class="n">overlapTime</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">totalTime</span><span class="p">)</span>

        <span class="n">percentOverlapFlag</span> <span class="o">=</span> <span class="n">percentOverlap</span> <span class="o">&gt;=</span> <span class="n">percentThreshold</span>

    <span class="c1"># Is the overlap more than a certain threshold?</span>
    <span class="n">timeOverlapFlag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">timeThreshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">overlapFlag</span><span class="p">:</span>
        <span class="n">timeOverlapFlag</span> <span class="o">=</span> <span class="n">overlapTime</span> <span class="o">&gt;</span> <span class="n">timeThreshold</span>

    <span class="n">overlapFlag</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">overlapFlag</span> <span class="ow">or</span> <span class="n">boundaryOverlapFlag</span> <span class="ow">or</span> <span class="n">percentOverlapFlag</span> <span class="ow">or</span> <span class="n">timeOverlapFlag</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">overlapFlag</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checks whether two intervals overlap</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>interval (Interval):</strong> </li>
<li><strong>cmprInterval (Interval):</strong> </li>
<li><strong>percentThreshold (float):</strong>  if percentThreshold is greater than 0, then
if the intervals overlap, they must overlap by at least this threshold</li>
<li><strong>timeThreshold (float):</strong>  if greater than 0, then if the intervals overlap,
they must overlap by at least this threshold</li>
<li><strong>boundaryInclusive (float):</strong>  if true, then two intervals are considered to
overlap if they share a boundary</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>bool:</p>
</blockquote>
</div>


                </section>
                <section id="TextgridCollisionException">
                                <div class="attr class">
        <a class="headerlink" href="#TextgridCollisionException">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TextgridCollisionException</span>(<span class="base">builtins.Exception</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TextgridCollisionException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tierName</span><span class="p">,</span> <span class="n">insertInterval</span><span class="p">,</span> <span class="n">collisionList</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TextgridCollisionException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierName</span> <span class="o">=</span> <span class="n">tierName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insertInterval</span> <span class="o">=</span> <span class="n">insertInterval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collisionList</span> <span class="o">=</span> <span class="n">collisionList</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dataTuple</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">insertInterval</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collisionList</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Attempted to insert interval </span><span class="si">%s</span><span class="s2"> into tier </span><span class="si">%s</span><span class="s2"> of textgrid&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;but overlapping entries </span><span class="si">%s</span><span class="s2"> already exist&quot;</span> <span class="o">%</span> <span class="n">dataTuple</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Common base class for all non-exit exceptions.</p>
</div>


                            <div id="TextgridCollisionException.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridCollisionException.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TextgridCollisionException</span><span class="signature">(tierName, insertInterval, collisionList)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tierName</span><span class="p">,</span> <span class="n">insertInterval</span><span class="p">,</span> <span class="n">collisionList</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TextgridCollisionException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierName</span> <span class="o">=</span> <span class="n">tierName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insertInterval</span> <span class="o">=</span> <span class="n">insertInterval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collisionList</span> <span class="o">=</span> <span class="n">collisionList</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.BaseException</dt>
                                <dd id="TextgridCollisionException.with_traceback" class="function">with_traceback</dd>
                <dd id="TextgridCollisionException.args" class="variable">args</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TimelessTextgridTierException">
                                <div class="attr class">
        <a class="headerlink" href="#TimelessTextgridTierException">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TimelessTextgridTierException</span>(<span class="base">builtins.Exception</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TimelessTextgridTierException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;All textgrid tiers much have a min and max duration&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Common base class for all non-exit exceptions.</p>
</div>


                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.Exception</dt>
                                <dd id="TimelessTextgridTierException.__init__" class="function">Exception</dd>

            </div>
            <div><dt>builtins.BaseException</dt>
                                <dd id="TimelessTextgridTierException.with_traceback" class="function">with_traceback</dd>
                <dd id="TimelessTextgridTierException.args" class="variable">args</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="BadIntervalError">
                                <div class="attr class">
        <a class="headerlink" href="#BadIntervalError">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BadIntervalError</span>(<span class="base">builtins.Exception</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BadIntervalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BadIntervalError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dataTuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Problem with interval--could not create textgrid &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">dataTuple</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Common base class for all non-exit exceptions.</p>
</div>


                            <div id="BadIntervalError.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BadIntervalError.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BadIntervalError</span><span class="signature">(start, stop, label)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BadIntervalError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.BaseException</dt>
                                <dd id="BadIntervalError.with_traceback" class="function">with_traceback</dd>
                <dd id="BadIntervalError.args" class="variable">args</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="BadFormatException">
                                <div class="attr class">
        <a class="headerlink" href="#BadFormatException">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BadFormatException</span>(<span class="base">builtins.Exception</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BadFormatException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectedFormat</span><span class="p">,</span> <span class="n">validFormatOptions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BadFormatException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selectedFormat</span> <span class="o">=</span> <span class="n">selectedFormat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validFormatOptions</span> <span class="o">=</span> <span class="n">validFormatOptions</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dataTuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selectedFormat</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">validFormatOptions</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Problem with format.  Received </span><span class="si">%s</span><span class="s2"> but format must be one of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dataTuple</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Common base class for all non-exit exceptions.</p>
</div>


                            <div id="BadFormatException.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BadFormatException.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BadFormatException</span><span class="signature">(selectedFormat, validFormatOptions)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectedFormat</span><span class="p">,</span> <span class="n">validFormatOptions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BadFormatException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selectedFormat</span> <span class="o">=</span> <span class="n">selectedFormat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validFormatOptions</span> <span class="o">=</span> <span class="n">validFormatOptions</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>builtins.BaseException</dt>
                                <dd id="BadFormatException.with_traceback" class="function">with_traceback</dd>
                <dd id="BadFormatException.args" class="variable">args</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TextgridTier">
                                <div class="attr class">
        <a class="headerlink" href="#TextgridTier">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TextgridTier</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TextgridTier</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">tierType</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">entryType</span> <span class="o">=</span> <span class="n">Interval</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See PointTier or IntervalTier&quot;&quot;&quot;</span>
        <span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">=</span> <span class="n">entryList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxT</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">isEqual</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">)</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isEqual</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">selfEntry</span><span class="p">,</span> <span class="n">otherEntry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">selfSubEntry</span><span class="p">,</span> <span class="n">otherSubEntry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">selfEntry</span><span class="p">,</span> <span class="n">otherEntry</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="n">selfSubEntry</span><span class="p">,</span> <span class="n">otherSubEntry</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">selfSubEntry</span> <span class="o">==</span> <span class="n">otherSubEntry</span>

        <span class="k">return</span> <span class="n">isEqual</span>

    <span class="k">def</span> <span class="nf">appendTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a tier to the end of this one.</span>

<span class="sd">        This tier&#39;s maxtimestamp will be lengthened by the amount in the passed in tier.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">minTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">&lt;</span> <span class="n">minTime</span><span class="p">:</span>
            <span class="n">minTime</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="n">maxTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="n">appendTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierType</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span>

        <span class="n">entryList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">+</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an entry from the entryList&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchLabel</span><span class="p">,</span> <span class="n">substrMatchFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usingRE</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of all intervals that match the given label</span>

<span class="sd">        Args:</span>
<span class="sd">            matchLabel (str): the label to search for</span>
<span class="sd">            substrMatchFlag (bool): if True, match any label containing matchLabel. if False, label must be the same as matchLabel.</span>
<span class="sd">            usingRE (bool): if True, matchLabel is interpreted as a regular expression</span>

<span class="sd">        Returns:</span>
<span class="sd">            List: A list of indicies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">returnList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">usingRE</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="n">matchList</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">matchLabel</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">matchList</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">substrMatchFlag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">matchLabel</span><span class="p">:</span>
                        <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">matchLabel</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">returnList</span>

    <span class="k">def</span> <span class="nf">getAsText</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints each entry in the tier on a separate line w/ timing info</span>

<span class="sd">        TODO: Delete this?  It was being used in writing shortform textgrids</span>
<span class="sd">              but is not anymore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierType</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">),</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">[</span><span class="n">numToStr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unicode</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="nb">str</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="n">unicode</span>

            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">unicodeFunc</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">entryList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a new tier derived from the current one&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">entryList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entryList</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>
            <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">entry</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">pairedWav</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts the entries in the entryList&quot;&quot;&quot;</span>
        <span class="c1"># A list containing tuples and lists will be sorted with tuples</span>
        <span class="c1"># first and then lists.  To correctly sort, we need to make</span>
        <span class="c1"># sure that all data structures inside the entry list are</span>
        <span class="c1"># of the same data type.  The entry list is sorted whenever</span>
        <span class="c1"># the entry list is modified, so this is probably the best</span>
        <span class="c1"># place to enforce the data type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The given tier is set unioned to this tier.</span>

<span class="sd">        All entries in the given tier are added to the current tier.</span>
<span class="sd">        Overlapping entries are merged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTier</span><span class="o">.</span><span class="n">insertEntry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">)</span>

        <span class="n">retTier</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">retTier</span>
</pre></div>

        </details>

    

                            <div id="TextgridTier.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TextgridTier</span><span class="signature">(name, entryList, minT, maxT, pairedWav=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See PointTier or IntervalTier&quot;&quot;&quot;</span>
        <span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">=</span> <span class="n">entryList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxT</span>
</pre></div>

        </details>

            <div class="docstring"><p>See PointTier or IntervalTier</p>
</div>


                            </div>
                            <div id="TextgridTier.tierType" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#TextgridTier.tierType">#&nbsp;&nbsp</a>

        <span class="name">tierType</span><span class="default_value"> = None</span>
    </div>

    

                            </div>
                            <div id="TextgridTier.appendTier" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.appendTier">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">appendTier</span><span class="signature">(self, tier)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">appendTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a tier to the end of this one.</span>

<span class="sd">        This tier&#39;s maxtimestamp will be lengthened by the amount in the passed in tier.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">minTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">&lt;</span> <span class="n">minTime</span><span class="p">:</span>
            <span class="n">minTime</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="n">maxTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="n">appendTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierType</span> <span class="o">==</span> <span class="n">tier</span><span class="o">.</span><span class="n">tierType</span>

        <span class="n">entryList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">+</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span>
        <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Append a tier to the end of this one.</p>

<p>This tier's maxtimestamp will be lengthened by the amount in the passed in tier.</p>
</div>


                            </div>
                            <div id="TextgridTier.deleteEntry" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.deleteEntry">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">deleteEntry</span><span class="signature">(self, entry)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an entry from the entryList&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Removes an entry from the entryList</p>
</div>


                            </div>
                            <div id="TextgridTier.find" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.find">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">find</span><span class="signature">(self, matchLabel, substrMatchFlag=False, usingRE=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchLabel</span><span class="p">,</span> <span class="n">substrMatchFlag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usingRE</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of all intervals that match the given label</span>

<span class="sd">        Args:</span>
<span class="sd">            matchLabel (str): the label to search for</span>
<span class="sd">            substrMatchFlag (bool): if True, match any label containing matchLabel. if False, label must be the same as matchLabel.</span>
<span class="sd">            usingRE (bool): if True, matchLabel is interpreted as a regular expression</span>

<span class="sd">        Returns:</span>
<span class="sd">            List: A list of indicies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">returnList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">usingRE</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="n">matchList</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">matchLabel</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">matchList</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">substrMatchFlag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">matchLabel</span><span class="p">:</span>
                        <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">matchLabel</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">returnList</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of all intervals that match the given label</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>matchLabel (str):</strong>  the label to search for</li>
<li><strong>substrMatchFlag (bool):</strong>  if True, match any label containing matchLabel. if False, label must be the same as matchLabel.</li>
<li><strong>usingRE (bool):</strong>  if True, matchLabel is interpreted as a regular expression</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>List: A list of indicies</p>
</blockquote>
</div>


                            </div>
                            <div id="TextgridTier.getAsText" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.getAsText">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getAsText</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getAsText</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints each entry in the tier on a separate line w/ timing info</span>

<span class="sd">        TODO: Delete this?  It was being used in writing shortform textgrids</span>
<span class="sd">              but is not anymore</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierType</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">),</span>
            <span class="n">numToStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="p">[</span><span class="n">numToStr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">entry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unicode</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="nb">str</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unicodeFunc</span> <span class="o">=</span> <span class="n">unicode</span>

            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">unicodeFunc</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">text</span>
</pre></div>

        </details>

            <div class="docstring"><p>Prints each entry in the tier on a separate line w/ timing info</p>

<p>TODO: Delete this?  It was being used in writing shortform textgrids
      but is not anymore</p>
</div>


                            </div>
                            <div id="TextgridTier.new" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.new">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">new</span><span class="signature">(
    self,
    name=None,
    entryList=None,
    minTimestamp=None,
    maxTimestamp=None,
    pairedWav=None
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">entryList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a new tier derived from the current one&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">entryList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entryList</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span>
            <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">entry</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minTimestamp</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">pairedWav</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Make a new tier derived from the current one</p>
</div>


                            </div>
                            <div id="TextgridTier.sort" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.sort">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sort</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts the entries in the entryList&quot;&quot;&quot;</span>
        <span class="c1"># A list containing tuples and lists will be sorted with tuples</span>
        <span class="c1"># first and then lists.  To correctly sort, we need to make</span>
        <span class="c1"># sure that all data structures inside the entry list are</span>
        <span class="c1"># of the same data type.  The entry list is sorted whenever</span>
        <span class="c1"># the entry list is modified, so this is probably the best</span>
        <span class="c1"># place to enforce the data type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryType</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sorts the entries in the entryList</p>
</div>


                            </div>
                            <div id="TextgridTier.union" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TextgridTier.union">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">union</span><span class="signature">(self, tier)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The given tier is set unioned to this tier.</span>

<span class="sd">        All entries in the given tier are added to the current tier.</span>
<span class="sd">        Overlapping entries are merged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTier</span><span class="o">.</span><span class="n">insertEntry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">)</span>

        <span class="n">retTier</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">retTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>The given tier is set unioned to this tier.</p>

<p>All entries in the given tier are added to the current tier.
Overlapping entries are merged.</p>
</div>


                            </div>
                </section>
                <section id="TextgridTier.entryType">
                                <div class="attr class">
        <a class="headerlink" href="#TextgridTier.entryType">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TextgridTier.entryType</span>(<span class="base">builtins.tuple</span>):
    </div>

        
            <div class="docstring"><p>Interval(start, end, label)</p>
</div>


                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Interval">Interval</a></dt>
                                <dd id="TextgridTier.entryType.__init__" class="function"><a href="#Interval.__init__">Interval</a></dd>
                <dd id="TextgridTier.entryType.start" class="variable"><a href="#Interval.start">start</a></dd>
                <dd id="TextgridTier.entryType.end" class="variable"><a href="#Interval.end">end</a></dd>
                <dd id="TextgridTier.entryType.label" class="variable"><a href="#Interval.label">label</a></dd>

            </div>
            <div><dt>builtins.tuple</dt>
                                <dd id="TextgridTier.entryType.index" class="function">index</dd>
                <dd id="TextgridTier.entryType.count" class="function">count</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PointTier">
                                <div class="attr class">
        <a class="headerlink" href="#PointTier">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PointTier</span>(<span class="base"><a href="#TextgridTier">TextgridTier</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PointTier</span><span class="p">(</span><span class="n">TextgridTier</span><span class="p">):</span>

    <span class="n">tierType</span> <span class="o">=</span> <span class="n">POINT_TIER</span>
    <span class="n">entryType</span> <span class="o">=</span> <span class="n">Point</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A point tier is for annotating instaneous events</span>

<span class="sd">        The entryList is of the form:</span>
<span class="sd">        [(timeVal1, label1), (timeVal2, label2), ]</span>

<span class="sd">        The data stored in the labels can be anything but will</span>
<span class="sd">        be interpreted as text by praatio (the label could be descriptive</span>
<span class="sd">        text e.g. (&#39;peak point here&#39;) or numerical data e.g. (pitch values</span>
<span class="sd">        like &#39;132&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>

        <span class="c1"># Determine the min and max timestamps</span>
        <span class="n">timeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span> <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">minT</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">maxT</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">_getWavDuration</span><span class="p">(</span><span class="n">pairedWav</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TimelessTextgridTierException</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PointTier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new tier containing all entries inside the new interval</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (str): Mode is ignored.  This parameter is kept for</span>
<span class="sd">                compatibility with IntervalTier.crop()</span>
<span class="sd">            rebaseToZero (bool): if True, all entries will have their</span>
<span class="sd">                timestamps subtracted by *cropStart*.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">timeV</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">timeV</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">]</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>

        <span class="k">return</span> <span class="n">PointTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (float):</span>
<span class="sd">            allowOvershoot (bool): if True, an interval can go beyond</span>
<span class="sd">                the bounds of the textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

            <span class="n">newTimestamp</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allowOvershoot</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">newTimestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
                <span class="k">assert</span> <span class="n">newTimestamp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

            <span class="k">if</span> <span class="n">newTimestamp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newTimestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="c1"># Determine new min and max timestamps</span>
        <span class="n">timeList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">subList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">]</span>
        <span class="n">newMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newMin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="k">if</span> <span class="n">newMax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">PointTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getValuesAtPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataTupleList</span><span class="p">,</span> <span class="n">fuzzyMatching</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values that occur at points in the point tier</span>

<span class="sd">        Args:</span>
<span class="sd">            dataTupleList (list):</span>
<span class="sd">            fuzzyMatching (bool): if True, if there is not a feature value</span>
<span class="sd">                at a point, the nearest feature value will be taken.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List</span>

<span class="sd">        The procedure assumes that all data is ordered in time.</span>
<span class="sd">        dataTupleList should be in the form</span>
<span class="sd">        [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]</span>

<span class="sd">        The procedure makes one pass through dataTupleList and one</span>
<span class="sd">        pass through self.entryList.  If the data is not sequentially</span>
<span class="sd">        ordered, the incorrect response will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">retList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">sortedDataTupleList</span> <span class="o">=</span> <span class="n">dataTupleList</span><span class="o">.</span><span class="n">sorted</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTuple</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getValueAtTime</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">,</span> <span class="n">sortedDataTupleList</span><span class="p">,</span> <span class="n">fuzzyMatching</span><span class="o">=</span><span class="n">fuzzyMatching</span><span class="p">,</span> <span class="n">startI</span><span class="o">=</span><span class="n">i</span>
            <span class="p">)</span>
            <span class="n">retTime</span><span class="p">,</span> <span class="n">retVal</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">retTuple</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">retTime</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">retVal</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">retList</span>

    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): the start of the deletion interval</span>
<span class="sd">            stop (float): the end of the deletion interval</span>
<span class="sd">            collisionCode (str): Ignored for the moment (added for compatibility with eraseRegion() for Interval Tiers)</span>
<span class="sd">            doShrink (bool): if True, moves leftward by (/stop/ - /start/) all points to the right of /stop/</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
        <span class="n">croppedTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">matchList</span> <span class="o">=</span> <span class="n">croppedTier</span><span class="o">.</span><span class="n">entryList</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Remove all the matches from the entryList</span>
            <span class="c1"># Go in reverse order because we&#39;re destructively altering</span>
            <span class="c1"># the order of the list (messes up index order)</span>
            <span class="k">for</span> <span class="n">tmpEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newTier</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">tmpEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

            <span class="n">newMax</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">-</span> <span class="n">diff</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">newMax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>

    <span class="k">def</span> <span class="nf">insertEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">warnFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inserts an interval into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (tuple|Point): the entry to insert</span>
<span class="sd">            warnFlag (bool): see below for details</span>
<span class="sd">            collisionCode (str): determines the behavior if intervals exist in</span>
<span class="sd">                the insertion area. One of (&#39;replace&#39;, &#39;merge&#39;, or None)</span>
<span class="sd">                - &#39;replace&#39;, existing items will be removed</span>
<span class="sd">                - &#39;merge&#39;, inserting item will be fused with existing items</span>
<span class="sd">                - None or any other value will thrown TextgridCollisionException</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        If warnFlag is True and collisionCode is not None, the user is notified</span>
<span class="sd">        of each collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">entry</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">searchEntry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">searchEntry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">matchList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">searchEntry</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
            <span class="n">oldEntry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">newEntry</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">oldEntry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TextgridCollisionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">matchList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warnFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Collision warning for </span><span class="si">%s</span><span class="s2"> with items </span><span class="si">%s</span><span class="s2"> of tier </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchList</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a region into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): the start time to insert a space at</span>
<span class="sd">            duration (float): the duration of the space to insert</span>
<span class="sd">            collisionCode (str): Ignored for the moment (added for compatibility with insertSpace() for Interval Tiers)</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>
</pre></div>

        </details>

    

                            <div id="PointTier.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PointTier</span><span class="signature">(name, entryList, minT=None, maxT=None, pairedWav=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A point tier is for annotating instaneous events</span>

<span class="sd">        The entryList is of the form:</span>
<span class="sd">        [(timeVal1, label1), (timeVal2, label2), ]</span>

<span class="sd">        The data stored in the labels can be anything but will</span>
<span class="sd">        be interpreted as text by praatio (the label could be descriptive</span>
<span class="sd">        text e.g. (&#39;peak point here&#39;) or numerical data e.g. (pitch values</span>
<span class="sd">        like &#39;132&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>

        <span class="c1"># Determine the min and max timestamps</span>
        <span class="n">timeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span> <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">minT</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">maxT</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">_getWavDuration</span><span class="p">(</span><span class="n">pairedWav</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TimelessTextgridTierException</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PointTier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A point tier is for annotating instaneous events</p>

<p>The entryList is of the form:
[(timeVal1, label1), (timeVal2, label2), ]</p>

<p>The data stored in the labels can be anything but will
be interpreted as text by praatio (the label could be descriptive
text e.g. ('peak point here') or numerical data e.g. (pitch values
like '132'))</p>
</div>


                            </div>
                            <div id="PointTier.tierType" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#PointTier.tierType">#&nbsp;&nbsp</a>

        <span class="name">tierType</span><span class="default_value"> = &#39;TextTier&#39;</span>
    </div>

    

                            </div>
                            <div id="PointTier.crop" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.crop">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">crop</span><span class="signature">(self, cropStart, cropEnd, mode=None, rebaseToZero=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new tier containing all entries inside the new interval</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (str): Mode is ignored.  This parameter is kept for</span>
<span class="sd">                compatibility with IntervalTier.crop()</span>
<span class="sd">            rebaseToZero (bool): if True, all entries will have their</span>
<span class="sd">                timestamps subtracted by *cropStart*.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">timeV</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">timeV</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">]</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>

        <span class="k">return</span> <span class="n">PointTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a new tier containing all entries inside the new interval</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cropStart (float):</strong> </li>
<li><strong>cropEnd (float):</strong> </li>
<li><strong>mode (str):</strong>  Mode is ignored.  This parameter is kept for
compatibility with <a href="#IntervalTier.crop">IntervalTier.crop()</a></li>
<li><strong>rebaseToZero (bool):</strong>  if True, all entries will have their
timestamps subtracted by <em>cropStart</em>.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>PointTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="PointTier.editTimestamps" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.editTimestamps">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">editTimestamps</span><span class="signature">(self, offset, allowOvershoot=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (float):</span>
<span class="sd">            allowOvershoot (bool): if True, an interval can go beyond</span>
<span class="sd">                the bounds of the textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

            <span class="n">newTimestamp</span> <span class="o">=</span> <span class="n">timestamp</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allowOvershoot</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">newTimestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
                <span class="k">assert</span> <span class="n">newTimestamp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

            <span class="k">if</span> <span class="n">newTimestamp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newTimestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="c1"># Determine new min and max timestamps</span>
        <span class="n">timeList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">subList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">]</span>
        <span class="n">newMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">timeList</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newMin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="k">if</span> <span class="n">newMax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">PointTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Modifies all timestamps by a constant amount</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>offset (float):</strong> </li>
<li><strong>allowOvershoot (bool):</strong>  if True, an interval can go beyond
the bounds of the textgrid</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>PointTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="PointTier.getValuesAtPoints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.getValuesAtPoints">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getValuesAtPoints</span><span class="signature">(self, dataTupleList, fuzzyMatching=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getValuesAtPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataTupleList</span><span class="p">,</span> <span class="n">fuzzyMatching</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values that occur at points in the point tier</span>

<span class="sd">        Args:</span>
<span class="sd">            dataTupleList (list):</span>
<span class="sd">            fuzzyMatching (bool): if True, if there is not a feature value</span>
<span class="sd">                at a point, the nearest feature value will be taken.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List</span>

<span class="sd">        The procedure assumes that all data is ordered in time.</span>
<span class="sd">        dataTupleList should be in the form</span>
<span class="sd">        [(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]</span>

<span class="sd">        The procedure makes one pass through dataTupleList and one</span>
<span class="sd">        pass through self.entryList.  If the data is not sequentially</span>
<span class="sd">        ordered, the incorrect response will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">retList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">sortedDataTupleList</span> <span class="o">=</span> <span class="n">dataTupleList</span><span class="o">.</span><span class="n">sorted</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTuple</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getValueAtTime</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">,</span> <span class="n">sortedDataTupleList</span><span class="p">,</span> <span class="n">fuzzyMatching</span><span class="o">=</span><span class="n">fuzzyMatching</span><span class="p">,</span> <span class="n">startI</span><span class="o">=</span><span class="n">i</span>
            <span class="p">)</span>
            <span class="n">retTime</span><span class="p">,</span> <span class="n">retVal</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">retTuple</span>
            <span class="n">retList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">retTime</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">retVal</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">retList</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the values that occur at points in the point tier</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>dataTupleList (list):</strong> </li>
<li><strong>fuzzyMatching (bool):</strong>  if True, if there is not a feature value
at a point, the nearest feature value will be taken.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>List</p>
</blockquote>

<p>The procedure assumes that all data is ordered in time.
dataTupleList should be in the form
[(t1, v1a, v1b, ..), (t2, v2a, v2b, ..), ..]</p>

<p>The procedure makes one pass through dataTupleList and one
pass through self.entryList.  If the data is not sequentially
ordered, the incorrect response will be returned.</p>
</div>


                            </div>
                            <div id="PointTier.eraseRegion" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.eraseRegion">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">eraseRegion</span><span class="signature">(self, start, stop, collisionCode=None, doShrink=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): the start of the deletion interval</span>
<span class="sd">            stop (float): the end of the deletion interval</span>
<span class="sd">            collisionCode (str): Ignored for the moment (added for compatibility with eraseRegion() for Interval Tiers)</span>
<span class="sd">            doShrink (bool): if True, moves leftward by (/stop/ - /start/) all points to the right of /stop/</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
        <span class="n">croppedTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">matchList</span> <span class="o">=</span> <span class="n">croppedTier</span><span class="o">.</span><span class="n">entryList</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Remove all the matches from the entryList</span>
            <span class="c1"># Go in reverse order because we&#39;re destructively altering</span>
            <span class="c1"># the order of the list (messes up index order)</span>
            <span class="k">for</span> <span class="n">tmpEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newTier</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">tmpEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

            <span class="n">newMax</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">-</span> <span class="n">diff</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">newMax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Makes a region in a tier blank (removes all contained entries)</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start (float):</strong>  the start of the deletion interval</li>
<li><strong>stop (float):</strong>  the end of the deletion interval</li>
<li><strong>collisionCode (str):</strong>  Ignored for the moment (added for compatibility with eraseRegion() for Interval Tiers)</li>
<li><strong>doShrink (bool):</strong>  if True, moves leftward by (/stop/ - /start/) all points to the right of /stop/</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>PointTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="PointTier.insertEntry" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.insertEntry">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">insertEntry</span><span class="signature">(self, entry, warnFlag=True, collisionCode=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">insertEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">warnFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inserts an interval into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (tuple|Point): the entry to insert</span>
<span class="sd">            warnFlag (bool): see below for details</span>
<span class="sd">            collisionCode (str): determines the behavior if intervals exist in</span>
<span class="sd">                the insertion area. One of (&#39;replace&#39;, &#39;merge&#39;, or None)</span>
<span class="sd">                - &#39;replace&#39;, existing items will be removed</span>
<span class="sd">                - &#39;merge&#39;, inserting item will be fused with existing items</span>
<span class="sd">                - None or any other value will thrown TextgridCollisionException</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        If warnFlag is True and collisionCode is not None, the user is notified</span>
<span class="sd">        of each collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">entry</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">searchEntry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">searchEntry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">matchList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">searchEntry</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
            <span class="n">oldEntry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">newEntry</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">oldEntry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TextgridCollisionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">matchList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warnFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Collision warning for </span><span class="si">%s</span><span class="s2"> with items </span><span class="si">%s</span><span class="s2"> of tier </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchList</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
</pre></div>

        </details>

            <div class="docstring"><p>inserts an interval into the tier</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>entry (tuple|Point):</strong>  the entry to insert</li>
<li><strong>warnFlag (bool):</strong>  see below for details</li>
<li><strong>collisionCode (str):</strong>  determines the behavior if intervals exist in
the insertion area. One of ('replace', 'merge', or None)
<ul>
<li>'replace', existing items will be removed</li>
<li>'merge', inserting item will be fused with existing items</li>
<li>None or any other value will thrown TextgridCollisionException</li>
</ul></li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>

<p>If warnFlag is True and collisionCode is not None, the user is notified
of each collision</p>
</div>


                            </div>
                            <div id="PointTier.insertSpace" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PointTier.insertSpace">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">insertSpace</span><span class="signature">(self, start, duration, collisionCode=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a region into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float): the start time to insert a space at</span>
<span class="sd">            duration (float): the duration of the space to insert</span>
<span class="sd">            collisionCode (str): Ignored for the moment (added for compatibility with insertSpace() for Interval Tiers)</span>

<span class="sd">        Returns:</span>
<span class="sd">            PointTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Inserts a region into the tier</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start (float):</strong>  the start time to insert a space at</li>
<li><strong>duration (float):</strong>  the duration of the space to insert</li>
<li><strong>collisionCode (str):</strong>  Ignored for the moment (added for compatibility with insertSpace() for Interval Tiers)</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>PointTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#TextgridTier">TextgridTier</a></dt>
                                <dd id="PointTier.appendTier" class="function"><a href="#TextgridTier.appendTier">appendTier</a></dd>
                <dd id="PointTier.deleteEntry" class="function"><a href="#TextgridTier.deleteEntry">deleteEntry</a></dd>
                <dd id="PointTier.find" class="function"><a href="#TextgridTier.find">find</a></dd>
                <dd id="PointTier.getAsText" class="function"><a href="#TextgridTier.getAsText">getAsText</a></dd>
                <dd id="PointTier.new" class="function"><a href="#TextgridTier.new">new</a></dd>
                <dd id="PointTier.sort" class="function"><a href="#TextgridTier.sort">sort</a></dd>
                <dd id="PointTier.union" class="function"><a href="#TextgridTier.union">union</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PointTier.entryType">
                                <div class="attr class">
        <a class="headerlink" href="#PointTier.entryType">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PointTier.entryType</span>(<span class="base">builtins.tuple</span>):
    </div>

        
            <div class="docstring"><p>Point(time, label)</p>
</div>


                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Point">Point</a></dt>
                                <dd id="PointTier.entryType.__init__" class="function"><a href="#Point.__init__">Point</a></dd>
                <dd id="PointTier.entryType.time" class="variable"><a href="#Point.time">time</a></dd>
                <dd id="PointTier.entryType.label" class="variable"><a href="#Point.label">label</a></dd>

            </div>
            <div><dt>builtins.tuple</dt>
                                <dd id="PointTier.entryType.index" class="function">index</dd>
                <dd id="PointTier.entryType.count" class="function">count</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntervalTier">
                                <div class="attr class">
        <a class="headerlink" href="#IntervalTier">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntervalTier</span>(<span class="base"><a href="#TextgridTier">TextgridTier</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntervalTier</span><span class="p">(</span><span class="n">TextgridTier</span><span class="p">):</span>

    <span class="n">tierType</span> <span class="o">=</span> <span class="n">INTERVAL_TIER</span>
    <span class="n">entryType</span> <span class="o">=</span> <span class="n">Interval</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An interval tier is for annotating events that have duration</span>

<span class="sd">        The entryList is of the form:</span>
<span class="sd">        [(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]</span>

<span class="sd">        The data stored in the labels can be anything but will</span>
<span class="sd">        be interpreted as text by praatio (the label could be descriptive</span>
<span class="sd">        text e.g. (&#39;erase this region&#39;) or numerical data e.g. (average pitch</span>
<span class="sd">        values like &#39;132&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxT</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">_getWavDuration</span><span class="p">(</span><span class="n">pairedWav</span><span class="p">)</span>

        <span class="c1"># Prevent poorly-formed textgrids from being created</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Anomaly: startTime=</span><span class="si">%f</span><span class="s2">, stopTime=</span><span class="si">%f</span><span class="s2">, label=</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
            <span class="k">assert</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Remove whitespace</span>
        <span class="n">tmpEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">:</span>
            <span class="n">tmpEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="n">tmpEntryList</span>

        <span class="c1"># Determine the minimum and maximum timestampes</span>
        <span class="n">minTimeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">subList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>
        <span class="n">maxTimeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">subList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minTimeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxTimeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxT</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minTimeList</span><span class="p">)</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxTimeList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TimelessTextgridTierException</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">IntervalTier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new tier with all entries that fit inside the new interval</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (string): one of [&#39;strict&#39;, &#39;lax&#39;, or &#39;truncated&#39;]</span>
<span class="sd">                - &#39;strict&#39;, only intervals wholly contained by the crop</span>
<span class="sd">                    interval will be kept</span>
<span class="sd">                - &#39;lax&#39;, partially contained intervals will be kept</span>
<span class="sd">                - &#39;truncated&#39;, partially contained intervals will be</span>
<span class="sd">                    truncated to fit within the crop region.</span>
<span class="sd">            rebaseToZero (bool): if True, the cropped textgrid values</span>
<span class="sd">                will be subtracted by the cropStart</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;strict&quot;</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>

        <span class="c1"># Debugging variables</span>
        <span class="n">cutTStart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cutTWithin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cutTEnd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">firstIntervalKeptProportion</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastIntervalKeptProportion</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">matchedEntry</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">intervalStart</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">intervalEnd</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">intervalLabel</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Don&#39;t need to investigate if the interval is before or after</span>
            <span class="c1"># the crop region</span>
            <span class="k">if</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropStart</span> <span class="ow">or</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Determine if the current subEntry is wholly contained</span>
            <span class="c1"># within the superEntry</span>
            <span class="k">if</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="c1"># If it is only partially contained within the superEntry AND</span>
            <span class="c1"># inclusion is &#39;lax&#39;, include it anyways</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lax&quot;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">or</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span>
            <span class="p">):</span>
                <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="c1"># If not strict, include partial tiers on the edges</span>
            <span class="c1"># -- regardless, record how much information was lost</span>
            <span class="c1">#        - for strict=True, the total time of the cut interval</span>
            <span class="c1">#        - for strict=False, the portion of the interval that lies</span>
            <span class="c1">#            outside the new interval</span>

            <span class="c1"># The current interval stradles the end of the new interval</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&gt;</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">cutTEnd</span> <span class="o">=</span> <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">cropEnd</span>
                <span class="n">lastIntervalKeptProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropEnd</span> <span class="o">-</span> <span class="n">intervalStart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervalStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="c1"># The current interval stradles the start of the new interval</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&lt;</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">cutTStart</span> <span class="o">=</span> <span class="n">cropStart</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="n">firstIntervalKeptProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">intervalEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="c1"># The current interval contains the new interval completely</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&lt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&gt;=</span> <span class="n">cropEnd</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lax&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="k">if</span> <span class="n">matchedEntry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matchedEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">startT</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">stopT</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">startT</span><span class="p">,</span> <span class="n">stopT</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newEntryList</span>
            <span class="p">]</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>

        <span class="c1"># Create subtier</span>
        <span class="n">croppedTier</span> <span class="o">=</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

        <span class="c1"># DEBUG info</span>
        <span class="c1">#         debugInfo = (subTier, cutTStart, cutTWithin, cutTEnd,</span>
        <span class="c1">#                      firstIntervalKeptProportion, lastIntervalKeptProportion)</span>

        <span class="k">return</span> <span class="n">croppedTier</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the set difference of this tier and the given one</span>

<span class="sd">        Any overlapping portions of entries with entries in this textgrid</span>
<span class="sd">        will be removed from the returned tier.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (IntervalTier):</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTier</span> <span class="o">=</span> <span class="n">retTier</span><span class="o">.</span><span class="n">eraseRegion</span><span class="p">(</span>
                <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">collisionCode</span><span class="o">=</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">retTier</span>

    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (start): the amount to shift all intervals</span>
<span class="sd">            allowOvershoot (bool): if True, an interval can</span>
<span class="sd">                go beyond the bounds of the textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

            <span class="n">newStart</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">start</span>
            <span class="n">newStop</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">stop</span>
            <span class="k">if</span> <span class="n">allowOvershoot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">newStart</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
                <span class="k">assert</span> <span class="n">newStop</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

            <span class="k">if</span> <span class="n">newStop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">newStart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newStart</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">newStart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newStart</span><span class="p">,</span> <span class="n">newStop</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="c1"># Determine new min and max timestamps</span>
        <span class="n">newMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">])</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">newMin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="k">if</span> <span class="n">newMax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            stop (float):</span>
<span class="sd">            collisionCode (bool): determines the behavior when the region to</span>
<span class="sd">                erase overlaps with existing intervals. One of [&#39;truncate&#39;,</span>
<span class="sd">                &#39;categorical&#39;, None]</span>
<span class="sd">                - &#39;truncate&#39; partially contained entries will have the portion</span>
<span class="sd">                    removed that overlaps with the target entry</span>
<span class="sd">                - &#39;categorical&#39; all entries that overlap, even partially, with</span>
<span class="sd">                    the target entry will be completely removed</span>
<span class="sd">                - None or any other value throws AssertionError</span>
<span class="sd">            doShrink (bool): if True, moves leftward by (/stop/ - /start/)</span>
<span class="sd">                amount, each item that occurs after /stop/</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="c1"># if the collisionCode is not properly set it isn&#39;t clear what to do</span>
        <span class="k">assert</span> <span class="n">collisionCode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="s2">&quot;categorical&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove all the matches from the entryList</span>
            <span class="c1"># Go in reverse order because we&#39;re destructively altering</span>
            <span class="c1"># the order of the list (messes up index order)</span>
            <span class="k">for</span> <span class="n">tmpEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newTier</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">tmpEntry</span><span class="p">)</span>

            <span class="c1"># If we&#39;re only truncating, reinsert entries on the left and</span>
            <span class="c1"># right edges</span>
            <span class="k">if</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;truncate&quot;</span><span class="p">:</span>

                <span class="c1"># Check left edge</span>
                <span class="k">if</span> <span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

                <span class="c1"># Check right edge</span>
                <span class="k">if</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

            <span class="c1"># Special case: an interval that spanned the deleted</span>
            <span class="c1"># section</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">rightEdge</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span>
                <span class="n">leftEdge</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span>
                <span class="n">sameLabel</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rightEdge</span> <span class="ow">and</span> <span class="n">leftEdge</span> <span class="ow">and</span> <span class="n">sameLabel</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>

                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newEntry</span><span class="p">)</span>

                    <span class="c1"># Only one interval can span the deleted section,</span>
                    <span class="c1"># so if we&#39;ve found it, move on</span>
                    <span class="k">break</span>

            <span class="n">newMax</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">-</span> <span class="n">diff</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">newMax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>

    <span class="k">def</span> <span class="nf">getValuesInIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataTupleList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns data from dataTupleList contained in labeled intervals</span>

<span class="sd">        dataTupleList should be of the form:</span>
<span class="sd">        [(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">returnList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">intervalDataList</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getValuesInInterval</span><span class="p">(</span>
                <span class="n">dataTupleList</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">interval</span><span class="p">,</span> <span class="n">intervalDataList</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">returnList</span>

    <span class="k">def</span> <span class="nf">getNonEntries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the regions of the textgrid without labels</span>

<span class="sd">        This can include unlabeled segments and regions marked as silent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">entryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Remove entries that have no duration (ie lie between two entries</span>
        <span class="c1"># that share a border)</span>
        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">invertedEntryList</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">invertedEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">invertedEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Interval</span><span class="p">)</span> <span class="k">else</span> <span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">invertedEntryList</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">invertedEntryList</span>

    <span class="k">def</span> <span class="nf">insertEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">warnFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inserts an interval into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (list|Interval): the Interval to insert</span>
<span class="sd">            warnFlag (bool):</span>
<span class="sd">            collisionCode: determines the behavior in the event that intervals</span>
<span class="sd">                exist in the insertion area.  One of [&#39;replace&#39;, &#39;merge&#39; None]</span>
<span class="sd">                - &#39;replace&#39; will remove existing items</span>
<span class="sd">                - &#39;merge&#39; will fuse the inserting item with existing items</span>
<span class="sd">                - None or any other value will throw a TextgridCollisionException</span>

<span class="sd">        if *warnFlag* is True and *collisionCode* is not None,</span>
<span class="sd">        the user is notified of each collision</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">entryList</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">matchEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">matchEntry</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">matchEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">matchEntry</span><span class="p">)</span>
            <span class="n">matchList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="n">matchList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># By starting time</span>

            <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
                <span class="nb">max</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
                <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">newEntry</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TextgridCollisionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">matchList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warnFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Collision warning for </span><span class="si">%s</span><span class="s2"> with items </span><span class="si">%s</span><span class="s2"> of tier </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchList</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a blank region into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            duration (float)</span>
<span class="sd">            collisionCode (str): determines the behavior that occurs if</span>
<span class="sd">                an interval stradles the starting pointone of [&#39;stretch&#39;,</span>
<span class="sd">                &#39;split&#39;, &#39;no change&#39;]</span>
<span class="sd">                - &#39;stretch&#39; stretches the interval by /duration/ amount</span>
<span class="sd">                - &#39;split&#39; splits the interval into two--everything to the</span>
<span class="sd">                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds</span>
<span class="sd">                - &#39;no change&#39; leaves the interval as is with no change</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the collisionCode is not properly set it isn&#39;t clear what to do</span>
        <span class="k">assert</span> <span class="n">collisionCode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stretch&quot;</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="s2">&quot;no change&quot;</span><span class="p">]</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="c1"># Entry exists before the insertion point</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="c1"># Entry exists after the insertion point</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="c1"># Entry straddles the insertion point</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;stretch&quot;</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;split&quot;</span><span class="p">:</span>
                    <span class="c1"># Left side of the split</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="c1"># Right side of the split</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                            <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">+</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span>
                            <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;no change&quot;</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the set intersection of this tier and the given one</span>

<span class="sd">        Only intervals that exist in both tiers will remain in the</span>
<span class="sd">        returned tier.  If intervals partially overlap, only the overlapping</span>
<span class="sd">        portion will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (IntervalTier): the tier to intersect with</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">subTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Combine the labels in the two tiers</span>
            <span class="n">stub</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%%</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="n">label</span>
            <span class="n">subEntryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">subEntry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subEntry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stub</span> <span class="o">%</span> <span class="n">subEntry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">subEntry</span> <span class="ow">in</span> <span class="n">subTier</span><span class="o">.</span><span class="n">entryList</span>
            <span class="p">]</span>

            <span class="n">retEntryList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subEntryList</span><span class="p">)</span>

        <span class="n">newName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newName</span><span class="p">,</span> <span class="n">retEntryList</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retTier</span>

    <span class="k">def</span> <span class="nf">morph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetTier</span><span class="p">,</span> <span class="n">filterFunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphs the duration of segments in this tier to those in another</span>

<span class="sd">        This preserves the labels and the duration of silence in</span>
<span class="sd">        this tier while changing the duration of labeled segments.</span>

<span class="sd">        Args:</span>
<span class="sd">            targetTier (IntervalTier):</span>
<span class="sd">            filterFunc (functor): if specified, filters entries. The</span>
<span class="sd">                functor takes one argument, an Interval. It returns true</span>
<span class="sd">                if the Interval should be modified and false if not.</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cumulativeAdjustAmount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastFromEnd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allPoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">,</span> <span class="n">targetTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">fromEntry</span><span class="p">,</span> <span class="n">targetEntry</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">safeZip</span><span class="p">(</span><span class="n">allPoints</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>

            <span class="n">fromStart</span><span class="p">,</span> <span class="n">fromEnd</span><span class="p">,</span> <span class="n">fromLabel</span> <span class="o">=</span> <span class="n">fromEntry</span>
            <span class="n">targetStart</span><span class="p">,</span> <span class="n">targetEnd</span> <span class="o">=</span> <span class="n">targetEntry</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># fromStart - lastFromEnd -&gt; was this interval and the</span>
            <span class="c1"># last one adjacent?</span>
            <span class="n">toStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">fromStart</span> <span class="o">-</span> <span class="n">lastFromEnd</span><span class="p">)</span> <span class="o">+</span> <span class="n">cumulativeAdjustAmount</span>

            <span class="n">currAdjustAmount</span> <span class="o">=</span> <span class="n">fromEnd</span> <span class="o">-</span> <span class="n">fromStart</span>
            <span class="k">if</span> <span class="n">filterFunc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filterFunc</span><span class="p">(</span><span class="n">fromLabel</span><span class="p">):</span>
                <span class="n">currAdjustAmount</span> <span class="o">=</span> <span class="n">targetEnd</span> <span class="o">-</span> <span class="n">targetStart</span>

            <span class="n">toEnd</span> <span class="o">=</span> <span class="n">cumulativeAdjustAmount</span> <span class="o">=</span> <span class="n">toStart</span> <span class="o">+</span> <span class="n">currAdjustAmount</span>
            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">toStart</span><span class="p">,</span> <span class="n">toEnd</span><span class="p">,</span> <span class="n">fromLabel</span><span class="p">))</span>

            <span class="n">lastFromEnd</span> <span class="o">=</span> <span class="n">fromEnd</span>

        <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">cumulativeDifference</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">cumulativeDifference</span>

        <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>
</pre></div>

        </details>

    

                            <div id="IntervalTier.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntervalTier</span><span class="signature">(name, entryList, minT=None, maxT=None, pairedWav=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pairedWav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An interval tier is for annotating events that have duration</span>

<span class="sd">        The entryList is of the form:</span>
<span class="sd">        [(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]</span>

<span class="sd">        The data stored in the labels can be anything but will</span>
<span class="sd">        be interpreted as text by praatio (the label could be descriptive</span>
<span class="sd">        text e.g. (&#39;erase this region&#39;) or numerical data e.g. (average pitch</span>
<span class="sd">        values like &#39;132&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxT</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pairedWav</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">_getWavDuration</span><span class="p">(</span><span class="n">pairedWav</span><span class="p">)</span>

        <span class="c1"># Prevent poorly-formed textgrids from being created</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Anomaly: startTime=</span><span class="si">%f</span><span class="s2">, stopTime=</span><span class="si">%f</span><span class="s2">, label=</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
            <span class="k">assert</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Remove whitespace</span>
        <span class="n">tmpEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">:</span>
            <span class="n">tmpEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="n">tmpEntryList</span>

        <span class="c1"># Determine the minimum and maximum timestampes</span>
        <span class="n">minTimeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">subList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>
        <span class="n">maxTimeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">subList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">subList</span> <span class="ow">in</span> <span class="n">entryList</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">minT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minTimeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxTimeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxT</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minTimeList</span><span class="p">)</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxTimeList</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TimelessTextgridTierException</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">IntervalTier</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">entryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>An interval tier is for annotating events that have duration</p>

<p>The entryList is of the form:
[(startTime1, endTime1, label1), (startTime2, endTime2, label2), ]</p>

<p>The data stored in the labels can be anything but will
be interpreted as text by praatio (the label could be descriptive
text e.g. ('erase this region') or numerical data e.g. (average pitch
values like '132'))</p>
</div>


                            </div>
                            <div id="IntervalTier.tierType" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntervalTier.tierType">#&nbsp;&nbsp</a>

        <span class="name">tierType</span><span class="default_value"> = &#39;IntervalTier&#39;</span>
    </div>

    

                            </div>
                            <div id="IntervalTier.crop" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.crop">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">crop</span><span class="signature">(self, cropStart, cropEnd, mode, rebaseToZero)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new tier with all entries that fit inside the new interval</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (string): one of [&#39;strict&#39;, &#39;lax&#39;, or &#39;truncated&#39;]</span>
<span class="sd">                - &#39;strict&#39;, only intervals wholly contained by the crop</span>
<span class="sd">                    interval will be kept</span>
<span class="sd">                - &#39;lax&#39;, partially contained intervals will be kept</span>
<span class="sd">                - &#39;truncated&#39;, partially contained intervals will be</span>
<span class="sd">                    truncated to fit within the crop region.</span>
<span class="sd">            rebaseToZero (bool): if True, the cropped textgrid values</span>
<span class="sd">                will be subtracted by the cropStart</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;strict&quot;</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>

        <span class="c1"># Debugging variables</span>
        <span class="n">cutTStart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cutTWithin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cutTEnd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">firstIntervalKeptProportion</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastIntervalKeptProportion</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">matchedEntry</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">intervalStart</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">intervalEnd</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">intervalLabel</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Don&#39;t need to investigate if the interval is before or after</span>
            <span class="c1"># the crop region</span>
            <span class="k">if</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropStart</span> <span class="ow">or</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Determine if the current subEntry is wholly contained</span>
            <span class="c1"># within the superEntry</span>
            <span class="k">if</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="c1"># If it is only partially contained within the superEntry AND</span>
            <span class="c1"># inclusion is &#39;lax&#39;, include it anyways</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lax&quot;</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">or</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span>
            <span class="p">):</span>
                <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="c1"># If not strict, include partial tiers on the edges</span>
            <span class="c1"># -- regardless, record how much information was lost</span>
            <span class="c1">#        - for strict=True, the total time of the cut interval</span>
            <span class="c1">#        - for strict=False, the portion of the interval that lies</span>
            <span class="c1">#            outside the new interval</span>

            <span class="c1"># The current interval stradles the end of the new interval</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&gt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&gt;</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">cutTEnd</span> <span class="o">=</span> <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">cropEnd</span>
                <span class="n">lastIntervalKeptProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropEnd</span> <span class="o">-</span> <span class="n">intervalStart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervalStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="c1"># The current interval stradles the start of the new interval</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&lt;</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&lt;=</span> <span class="n">cropEnd</span><span class="p">:</span>
                <span class="n">cutTStart</span> <span class="o">=</span> <span class="n">cropStart</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="n">firstIntervalKeptProportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">intervalEnd</span> <span class="o">-</span> <span class="n">intervalStart</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">intervalEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="c1"># The current interval contains the new interval completely</span>
            <span class="k">elif</span> <span class="n">intervalStart</span> <span class="o">&lt;=</span> <span class="n">cropStart</span> <span class="ow">and</span> <span class="n">intervalEnd</span> <span class="o">&gt;=</span> <span class="n">cropEnd</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;lax&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;truncated&quot;</span><span class="p">:</span>
                    <span class="n">matchedEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">intervalLabel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cutTWithin</span> <span class="o">+=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>

            <span class="k">if</span> <span class="n">matchedEntry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matchedEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">startT</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">stopT</span> <span class="o">-</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">startT</span><span class="p">,</span> <span class="n">stopT</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">newEntryList</span>
            <span class="p">]</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>

        <span class="c1"># Create subtier</span>
        <span class="n">croppedTier</span> <span class="o">=</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">minT</span><span class="p">,</span> <span class="n">maxT</span><span class="p">)</span>

        <span class="c1"># DEBUG info</span>
        <span class="c1">#         debugInfo = (subTier, cutTStart, cutTWithin, cutTEnd,</span>
        <span class="c1">#                      firstIntervalKeptProportion, lastIntervalKeptProportion)</span>

        <span class="k">return</span> <span class="n">croppedTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a new tier with all entries that fit inside the new interval</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cropStart (float):</strong> </li>
<li><strong>cropEnd (float):</strong> </li>
<li><strong>mode (string):</strong>  one of ['strict', 'lax', or 'truncated']
<ul>
<li>'strict', only intervals wholly contained by the crop
interval will be kept</li>
<li>'lax', partially contained intervals will be kept</li>
<li>'truncated', partially contained intervals will be
truncated to fit within the crop region.</li>
</ul></li>
<li><strong>rebaseToZero (bool):</strong>  if True, the cropped textgrid values
will be subtracted by the cropStart</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.difference" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.difference">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">difference</span><span class="signature">(self, tier)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the set difference of this tier and the given one</span>

<span class="sd">        Any overlapping portions of entries with entries in this textgrid</span>
<span class="sd">        will be removed from the returned tier.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (IntervalTier):</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">retTier</span> <span class="o">=</span> <span class="n">retTier</span><span class="o">.</span><span class="n">eraseRegion</span><span class="p">(</span>
                <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">collisionCode</span><span class="o">=</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">retTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Takes the set difference of this tier and the given one</p>

<p>Any overlapping portions of entries with entries in this textgrid
will be removed from the returned tier.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tier (IntervalTier):</strong> </li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.editTimestamps" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.editTimestamps">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">editTimestamps</span><span class="signature">(self, offset, allowOvershoot=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (start): the amount to shift all intervals</span>
<span class="sd">            allowOvershoot (bool): if True, an interval can</span>
<span class="sd">                go beyond the bounds of the textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>

            <span class="n">newStart</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">start</span>
            <span class="n">newStop</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">stop</span>
            <span class="k">if</span> <span class="n">allowOvershoot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">newStart</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
                <span class="k">assert</span> <span class="n">newStop</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

            <span class="k">if</span> <span class="n">newStop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">newStart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newStart</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">newStart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newStart</span><span class="p">,</span> <span class="n">newStop</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>

        <span class="c1"># Determine new min and max timestamps</span>
        <span class="n">newMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">])</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newEntryList</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">newMin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>

        <span class="k">if</span> <span class="n">newMax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Modifies all timestamps by a constant amount</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>offset (start):</strong>  the amount to shift all intervals</li>
<li><strong>allowOvershoot (bool):</strong>  if True, an interval can
go beyond the bounds of the textgrid</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.eraseRegion" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.eraseRegion">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">eraseRegion</span><span class="signature">(self, start, stop, collisionCode=None, doShrink=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            stop (float):</span>
<span class="sd">            collisionCode (bool): determines the behavior when the region to</span>
<span class="sd">                erase overlaps with existing intervals. One of [&#39;truncate&#39;,</span>
<span class="sd">                &#39;categorical&#39;, None]</span>
<span class="sd">                - &#39;truncate&#39; partially contained entries will have the portion</span>
<span class="sd">                    removed that overlaps with the target entry</span>
<span class="sd">                - &#39;categorical&#39; all entries that overlap, even partially, with</span>
<span class="sd">                    the target entry will be completely removed</span>
<span class="sd">                - None or any other value throws AssertionError</span>
<span class="sd">            doShrink (bool): if True, moves leftward by (/stop/ - /start/)</span>
<span class="sd">                amount, each item that occurs after /stop/</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

        <span class="c1"># if the collisionCode is not properly set it isn&#39;t clear what to do</span>
        <span class="k">assert</span> <span class="n">collisionCode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="s2">&quot;categorical&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove all the matches from the entryList</span>
            <span class="c1"># Go in reverse order because we&#39;re destructively altering</span>
            <span class="c1"># the order of the list (messes up index order)</span>
            <span class="k">for</span> <span class="n">tmpEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newTier</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">tmpEntry</span><span class="p">)</span>

            <span class="c1"># If we&#39;re only truncating, reinsert entries on the left and</span>
            <span class="c1"># right edges</span>
            <span class="k">if</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;truncate&quot;</span><span class="p">:</span>

                <span class="c1"># Check left edge</span>
                <span class="k">if</span> <span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">matchList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

                <span class="c1"># Check right edge</span>
                <span class="k">if</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">matchList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEntry</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">newTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

            <span class="c1"># Special case: an interval that spanned the deleted</span>
            <span class="c1"># section</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEntryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">rightEdge</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span>
                <span class="n">leftEdge</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span>
                <span class="n">sameLabel</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rightEdge</span> <span class="ow">and</span> <span class="n">leftEdge</span> <span class="ow">and</span> <span class="n">sameLabel</span><span class="p">:</span>
                    <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">newEntryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>

                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newEntry</span><span class="p">)</span>

                    <span class="c1"># Only one interval can span the deleted section,</span>
                    <span class="c1"># so if we&#39;ve found it, move on</span>
                    <span class="k">break</span>

            <span class="n">newMax</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">-</span> <span class="n">diff</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">newTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">newMax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Makes a region in a tier blank (removes all contained entries)</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start (float):</strong> </li>
<li><strong>stop (float):</strong> </li>
<li><strong>collisionCode (bool):</strong>  determines the behavior when the region to
erase overlaps with existing intervals. One of ['truncate',
'categorical', None]
<ul>
<li>'truncate' partially contained entries will have the portion
removed that overlaps with the target entry</li>
<li>'categorical' all entries that overlap, even partially, with
the target entry will be completely removed</li>
<li>None or any other value throws AssertionError</li>
</ul></li>
<li><strong>doShrink (bool):</strong>  if True, moves leftward by (/stop/ - /start/)
amount, each item that occurs after /stop/</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.getValuesInIntervals" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.getValuesInIntervals">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getValuesInIntervals</span><span class="signature">(self, dataTupleList)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getValuesInIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataTupleList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns data from dataTupleList contained in labeled intervals</span>

<span class="sd">        dataTupleList should be of the form:</span>
<span class="sd">        [(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">returnList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">intervalDataList</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">getValuesInInterval</span><span class="p">(</span>
                <span class="n">dataTupleList</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">returnList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">interval</span><span class="p">,</span> <span class="n">intervalDataList</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">returnList</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns data from dataTupleList contained in labeled intervals</p>

<p>dataTupleList should be of the form:
[(time1, value1a, value1b,...), (time2, value2a, value2b...), ...]</p>
</div>


                            </div>
                            <div id="IntervalTier.getNonEntries" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.getNonEntries">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getNonEntries</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getNonEntries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the regions of the textgrid without labels</span>

<span class="sd">        This can include unlabeled segments and regions marked as silent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entryList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span>
        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">entryList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">entryList</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entryList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Remove entries that have no duration (ie lie between two entries</span>
        <span class="c1"># that share a border)</span>
        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">invertedEntryList</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">invertedEntryList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">entryList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="n">invertedEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="n">invertedEntryList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">entry</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">Interval</span><span class="p">)</span> <span class="k">else</span> <span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">invertedEntryList</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">invertedEntryList</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the regions of the textgrid without labels</p>

<p>This can include unlabeled segments and regions marked as silent.</p>
</div>


                            </div>
                            <div id="IntervalTier.insertEntry" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.insertEntry">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">insertEntry</span><span class="signature">(self, entry, warnFlag=True, collisionCode=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">insertEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">warnFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inserts an interval into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (list|Interval): the Interval to insert</span>
<span class="sd">            warnFlag (bool):</span>
<span class="sd">            collisionCode: determines the behavior in the event that intervals</span>
<span class="sd">                exist in the insertion area.  One of [&#39;replace&#39;, &#39;merge&#39; None]</span>
<span class="sd">                - &#39;replace&#39; will remove existing items</span>
<span class="sd">                - &#39;merge&#39; will fuse the inserting item with existing items</span>
<span class="sd">                - None or any other value will throw a TextgridCollisionException</span>

<span class="sd">        if *warnFlag* is True and *collisionCode* is not None,</span>
<span class="sd">        the user is notified of each collision</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">matchList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">startTime</span><span class="p">,</span> <span class="n">endTime</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">entryList</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">matchEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">matchEntry</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collisionCode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;merge&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">matchEntry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deleteEntry</span><span class="p">(</span><span class="n">matchEntry</span><span class="p">)</span>
            <span class="n">matchList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="n">matchList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># By starting time</span>

            <span class="n">newEntry</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
                <span class="nb">max</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
                <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">matchList</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">*</span><span class="n">newEntry</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TextgridCollisionException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">matchList</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warnFlag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmtStr</span> <span class="o">=</span> <span class="s2">&quot;Collision warning for </span><span class="si">%s</span><span class="s2"> with items </span><span class="si">%s</span><span class="s2"> of tier </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">fmtStr</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">matchList</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
</pre></div>

        </details>

            <div class="docstring"><p>inserts an interval into the tier</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>entry (list|Interval):</strong>  the Interval to insert</li>
<li><strong>warnFlag (bool):</strong> </li>
<li><strong>collisionCode:</strong>  determines the behavior in the event that intervals
exist in the insertion area.  One of ['replace', 'merge' None]
<ul>
<li>'replace' will remove existing items</li>
<li>'merge' will fuse the inserting item with existing items</li>
<li>None or any other value will throw a TextgridCollisionException</li>
</ul></li>
</ul>

<p>if <em>warnFlag</em> is True and <em>collisionCode</em> is not None,
the user is notified of each collision</p>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.insertSpace" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.insertSpace">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">insertSpace</span><span class="signature">(self, start, duration, collisionCode=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a blank region into the tier</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            duration (float)</span>
<span class="sd">            collisionCode (str): determines the behavior that occurs if</span>
<span class="sd">                an interval stradles the starting pointone of [&#39;stretch&#39;,</span>
<span class="sd">                &#39;split&#39;, &#39;no change&#39;]</span>
<span class="sd">                - &#39;stretch&#39; stretches the interval by /duration/ amount</span>
<span class="sd">                - &#39;split&#39; splits the interval into two--everything to the</span>
<span class="sd">                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds</span>
<span class="sd">                - &#39;no change&#39; leaves the interval as is with no change</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the collisionCode is not properly set it isn&#39;t clear what to do</span>
        <span class="k">assert</span> <span class="n">collisionCode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stretch&quot;</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="s2">&quot;no change&quot;</span><span class="p">]</span>

        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="c1"># Entry exists before the insertion point</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="c1"># Entry exists after the insertion point</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="c1"># Entry straddles the insertion point</span>
            <span class="k">elif</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;stretch&quot;</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;split&quot;</span><span class="p">:</span>
                    <span class="c1"># Left side of the split</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="c1"># Right side of the split</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span>
                            <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">+</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span>
                            <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">collisionCode</span> <span class="o">==</span> <span class="s2">&quot;no change&quot;</span><span class="p">:</span>
                    <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="n">newTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
            <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">newTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Inserts a blank region into the tier</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start (float):</strong> </li>
<li>duration (float)</li>
<li><strong>collisionCode (str):</strong>  determines the behavior that occurs if
an interval stradles the starting pointone of ['stretch',
'split', 'no change']
<ul>
<li>'stretch' stretches the interval by /duration/ amount</li>
<li>'split' splits the interval into two--everything to the
right of 'start' will be advanced by 'duration' seconds</li>
<li>'no change' leaves the interval as is with no change</li>
</ul></li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.intersection" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.intersection">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">intersection</span><span class="signature">(self, tier)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the set intersection of this tier and the given one</span>

<span class="sd">        Only intervals that exist in both tiers will remain in the</span>
<span class="sd">        returned tier.  If intervals partially overlap, only the overlapping</span>
<span class="sd">        portion will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (IntervalTier): the tier to intersect with</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">:</span>
            <span class="n">subTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Combine the labels in the two tiers</span>
            <span class="n">stub</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%%</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="n">label</span>
            <span class="n">subEntryList</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">subEntry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subEntry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stub</span> <span class="o">%</span> <span class="n">subEntry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">subEntry</span> <span class="ow">in</span> <span class="n">subTier</span><span class="o">.</span><span class="n">entryList</span>
            <span class="p">]</span>

            <span class="n">retEntryList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subEntryList</span><span class="p">)</span>

        <span class="n">newName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">retTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newName</span><span class="p">,</span> <span class="n">retEntryList</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retTier</span>
</pre></div>

        </details>

            <div class="docstring"><p>Takes the set intersection of this tier and the given one</p>

<p>Only intervals that exist in both tiers will remain in the
returned tier.  If intervals partially overlap, only the overlapping
portion will be returned.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tier (IntervalTier):</strong>  the tier to intersect with</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div id="IntervalTier.morph" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalTier.morph">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">morph</span><span class="signature">(self, targetTier, filterFunc=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">morph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetTier</span><span class="p">,</span> <span class="n">filterFunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Morphs the duration of segments in this tier to those in another</span>

<span class="sd">        This preserves the labels and the duration of silence in</span>
<span class="sd">        this tier while changing the duration of labeled segments.</span>

<span class="sd">        Args:</span>
<span class="sd">            targetTier (IntervalTier):</span>
<span class="sd">            filterFunc (functor): if specified, filters entries. The</span>
<span class="sd">                functor takes one argument, an Interval. It returns true</span>
<span class="sd">                if the Interval should be modified and false if not.</span>

<span class="sd">        Returns:</span>
<span class="sd">            IntervalTier: the modified version of the current tier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cumulativeAdjustAmount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastFromEnd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newEntryList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allPoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">,</span> <span class="n">targetTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">fromEntry</span><span class="p">,</span> <span class="n">targetEntry</span> <span class="ow">in</span> <span class="n">utils</span><span class="o">.</span><span class="n">safeZip</span><span class="p">(</span><span class="n">allPoints</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>

            <span class="n">fromStart</span><span class="p">,</span> <span class="n">fromEnd</span><span class="p">,</span> <span class="n">fromLabel</span> <span class="o">=</span> <span class="n">fromEntry</span>
            <span class="n">targetStart</span><span class="p">,</span> <span class="n">targetEnd</span> <span class="o">=</span> <span class="n">targetEntry</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># fromStart - lastFromEnd -&gt; was this interval and the</span>
            <span class="c1"># last one adjacent?</span>
            <span class="n">toStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">fromStart</span> <span class="o">-</span> <span class="n">lastFromEnd</span><span class="p">)</span> <span class="o">+</span> <span class="n">cumulativeAdjustAmount</span>

            <span class="n">currAdjustAmount</span> <span class="o">=</span> <span class="n">fromEnd</span> <span class="o">-</span> <span class="n">fromStart</span>
            <span class="k">if</span> <span class="n">filterFunc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filterFunc</span><span class="p">(</span><span class="n">fromLabel</span><span class="p">):</span>
                <span class="n">currAdjustAmount</span> <span class="o">=</span> <span class="n">targetEnd</span> <span class="o">-</span> <span class="n">targetStart</span>

            <span class="n">toEnd</span> <span class="o">=</span> <span class="n">cumulativeAdjustAmount</span> <span class="o">=</span> <span class="n">toStart</span> <span class="o">+</span> <span class="n">currAdjustAmount</span>
            <span class="n">newEntryList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">toStart</span><span class="p">,</span> <span class="n">toEnd</span><span class="p">,</span> <span class="n">fromLabel</span><span class="p">))</span>

            <span class="n">lastFromEnd</span> <span class="o">=</span> <span class="n">fromEnd</span>

        <span class="n">newMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">cumulativeDifference</span> <span class="o">=</span> <span class="n">newEntryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">entryList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">cumulativeDifference</span>

        <span class="k">return</span> <span class="n">IntervalTier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">newEntryList</span><span class="p">,</span> <span class="n">newMin</span><span class="p">,</span> <span class="n">newMax</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Morphs the duration of segments in this tier to those in another</p>

<p>This preserves the labels and the duration of silence in
this tier while changing the duration of labeled segments.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>targetTier (IntervalTier):</strong> </li>
<li><strong>filterFunc (functor):</strong>  if specified, filters entries. The
functor takes one argument, an Interval. It returns true
if the Interval should be modified and false if not.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>IntervalTier: the modified version of the current tier</p>
</blockquote>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#TextgridTier">TextgridTier</a></dt>
                                <dd id="IntervalTier.appendTier" class="function"><a href="#TextgridTier.appendTier">appendTier</a></dd>
                <dd id="IntervalTier.deleteEntry" class="function"><a href="#TextgridTier.deleteEntry">deleteEntry</a></dd>
                <dd id="IntervalTier.find" class="function"><a href="#TextgridTier.find">find</a></dd>
                <dd id="IntervalTier.getAsText" class="function"><a href="#TextgridTier.getAsText">getAsText</a></dd>
                <dd id="IntervalTier.new" class="function"><a href="#TextgridTier.new">new</a></dd>
                <dd id="IntervalTier.sort" class="function"><a href="#TextgridTier.sort">sort</a></dd>
                <dd id="IntervalTier.union" class="function"><a href="#TextgridTier.union">union</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntervalTier.entryType">
                                <div class="attr class">
        <a class="headerlink" href="#IntervalTier.entryType">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntervalTier.entryType</span>(<span class="base">builtins.tuple</span>):
    </div>

        
            <div class="docstring"><p>Interval(start, end, label)</p>
</div>


                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Interval">Interval</a></dt>
                                <dd id="IntervalTier.entryType.__init__" class="function"><a href="#Interval.__init__">Interval</a></dd>
                <dd id="IntervalTier.entryType.start" class="variable"><a href="#Interval.start">start</a></dd>
                <dd id="IntervalTier.entryType.end" class="variable"><a href="#Interval.end">end</a></dd>
                <dd id="IntervalTier.entryType.label" class="variable"><a href="#Interval.label">label</a></dd>

            </div>
            <div><dt>builtins.tuple</dt>
                                <dd id="IntervalTier.entryType.index" class="function">index</dd>
                <dd id="IntervalTier.entryType.count" class="function">count</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Textgrid">
                                <div class="attr class">
        <a class="headerlink" href="#Textgrid">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Textgrid</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Textgrid</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;A container that stores and operates over interval and point tiers&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Preserves the order of the tiers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">isEqual</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">)</span>
        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="n">_isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>

        <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tierNameList</span>
        <span class="k">if</span> <span class="n">isEqual</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                <span class="n">isEqual</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">isEqual</span>

    <span class="k">def</span> <span class="nf">addTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">tierIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a tier to this textgrid.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (TextgridTier):</span>
<span class="sd">            tierIndex (int): if specified, insert the tier into the specified position</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">tierIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">tierIndex</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tier</span>

        <span class="n">minV</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">minV</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minV</span>

        <span class="n">maxV</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">maxV</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxV</span>

    <span class="k">def</span> <span class="nf">appendTextgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">onlyMatchingNames</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append one textgrid to the end of this one</span>

<span class="sd">        Args:</span>
<span class="sd">            tg (Textgrid): the tier to add to this one</span>
<span class="sd">            onlyMatchingNames (bool): if False, tiers that don&#39;t appear in both</span>
<span class="sd">                textgrids will also appear</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="n">minTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">maxTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="c1"># Get all tier names.  Ordered first by this textgrid and</span>
        <span class="c1"># then by the other textgrid.</span>
        <span class="n">combinedTierNameList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">combinedTierNameList</span><span class="p">:</span>
                <span class="n">combinedTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Determine the tier names that will be in the final textgrid</span>
        <span class="n">finalTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">onlyMatchingNames</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">finalTierNameList</span> <span class="o">=</span> <span class="n">combinedTierNameList</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">combinedTierNameList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                        <span class="n">finalTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Add tiers from this textgrid</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">finalTierNameList</span><span class="p">:</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                <span class="n">retTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="c1"># Add tiers from the given textgrid</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">finalTierNameList</span><span class="p">:</span>
                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">)</span>

                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                    <span class="n">newEntryList</span> <span class="o">=</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span><span class="o">.</span><span class="n">entryList</span>
                    <span class="n">newEntryList</span> <span class="o">+=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">entryList</span>

                    <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
                        <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span>
                        <span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span>
                        <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">retTG</span><span class="o">.</span><span class="n">replaceTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">appendTier</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">)</span>
                    <span class="n">retTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retTG</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a textgrid where all intervals fit within the crop region</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (str): one of [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;]</span>
<span class="sd">                - &#39;strict&#39;, only intervals wholly contained by the crop</span>
<span class="sd">                    interval will be kept</span>
<span class="sd">                - &#39;lax&#39;, partially contained intervals will be kept</span>
<span class="sd">                - &#39;truncated&#39;, partially contained intervals will be</span>
<span class="sd">                    truncated to fit within the crop region.</span>
<span class="sd">            rebaseToZero (bool): if True, the cropped textgrid values will be</span>
<span class="sd">                subtracted by the cropStart</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;strict&quot;</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minT</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxT</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTG</span>

    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            stop (float):</span>
<span class="sd">            doShrink (bool): if True, all entries appearing after the</span>
<span class="sd">                erased interval will be shifted to fill the void (ie</span>
<span class="sd">                the duration of the textgrid will be reduced by</span>
<span class="sd">                *start* - *stop*)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

        <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">maxTimestamp</span> <span class="o">-=</span> <span class="n">diff</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">eraseRegion</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="n">doShrink</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">newTG</span>

    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (float): the amount to offset in seconds</span>
<span class="sd">            allowOvershoot (bool): if True, entries can go</span>
<span class="sd">                beyond the min and max timestamp set by the</span>
<span class="sd">                Textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="p">)</span>

            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tg</span>

    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a blank region into a textgrid</span>

<span class="sd">        Every item that occurs after *start* will be pushed back by</span>
<span class="sd">        *duration* seconds</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            duration (float):</span>
<span class="sd">            collisionCode (str): Determines behaviour in the event that an</span>
<span class="sd">                interval stradles the starting point.</span>
<span class="sd">                One of [&#39;stretch&#39;, &#39;split&#39;, &#39;no change&#39;, None]</span>
<span class="sd">                - &#39;stretch&#39; stretches the interval by /duration/ amount</span>
<span class="sd">                - &#39;split&#39; splits the interval into two--everything to the</span>
<span class="sd">                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds</span>
<span class="sd">                - &#39;no change&#39; leaves the interval as is with no change</span>
<span class="sd">                - None or any other value throws an AssertionError</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>

        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">insertSpace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTG</span>

    <span class="k">def</span> <span class="nf">mergeTiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includeFunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tierList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preserveOtherTiers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine tiers</span>

<span class="sd">        Args:</span>
<span class="sd">            includeFunc (functor): regulates which intervals to include in the</span>
<span class="sd">                merging with all others being tossed (default accepts all)</span>
<span class="sd">            tierList (list): A list of tier names to combine. If none, combine</span>
<span class="sd">                all tiers.</span>
<span class="sd">            preserveOtherTiers (bool): If false, uncombined tiers are not</span>
<span class="sd">                included in the output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tierList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tierList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span>

        <span class="k">if</span> <span class="n">includeFunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">includeFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">entryList</span><span class="p">:</span> <span class="kc">True</span>

        <span class="c1"># Determine the tiers to merge</span>
        <span class="n">intervalTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pointTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tierList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">IntervalTier</span><span class="p">):</span>
                <span class="n">intervalTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">PointTier</span><span class="p">):</span>
                <span class="n">pointTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Merge the interval tiers</span>
        <span class="n">intervalTier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervalTierNameList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">intervalTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">intervalTierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">intervalTierNameList</span><span class="p">:</span>
            <span class="n">intervalTier</span> <span class="o">=</span> <span class="n">intervalTier</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">])</span>

        <span class="c1"># Merge the point tiers</span>
        <span class="n">pointTier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointTierNameList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pointTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">pointTierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">pointTierNameList</span><span class="p">:</span>
            <span class="n">pointTier</span> <span class="o">=</span> <span class="n">pointTier</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">])</span>

        <span class="c1"># Create the final textgrid to output</span>
        <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">intervalTier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">intervalTier</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pointTier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">pointTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tg</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of this Textgrid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">renameTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldName</span><span class="p">,</span> <span class="n">newName</span><span class="p">):</span>
        <span class="n">oldTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">oldName</span><span class="p">]</span>
        <span class="n">tierIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">oldName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeTier</span><span class="p">(</span><span class="n">oldName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">oldTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newName</span><span class="p">,</span> <span class="n">oldTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span> <span class="n">tierIndex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">removeTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replaceTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newTier</span><span class="p">):</span>
        <span class="n">tierIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeTier</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">,</span> <span class="n">tierIndex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">,</span>
        <span class="n">minimumIntervalLength</span><span class="o">=</span><span class="n">MIN_INTERVAL_LENGTH</span><span class="p">,</span>
        <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">useShortForm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">outputFormat</span><span class="o">=</span><span class="n">TEXTGRID</span><span class="p">,</span>
        <span class="n">ignoreBlankSpaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To save the current textgrid</span>

<span class="sd">        Args:</span>
<span class="sd">            fn (str): the fullpath filename of the output</span>
<span class="sd">            minimumIntervalLength (float): any labeled intervals smaller</span>
<span class="sd">                than this will be removed, useful for removing ultrashort</span>
<span class="sd">                or fragmented intervals; if None, don&#39;t remove any.</span>
<span class="sd">                Removed intervals are merged (without their label) into</span>
<span class="sd">                adjacent entries.</span>
<span class="sd">            minTimestamp (float): the minTimestamp of the saved Textgrid;</span>
<span class="sd">                if None, use whatever is defined in the Textgrid object.</span>
<span class="sd">                If minTimestamp is larger than timestamps in your textgrid,</span>
<span class="sd">                an exception will be thrown.</span>
<span class="sd">            maxTimestamp (float): the maxTimestamp of the saved Textgrid;</span>
<span class="sd">                if None, use whatever is defined in the Textgrid object.</span>
<span class="sd">                If maxTimestamp is smaller than timestamps in your textgrid,</span>
<span class="sd">                an exception will be thrown.</span>
<span class="sd">            useShortForm (bool): if True, save the textgrid as a short</span>
<span class="sd">                textgrid. Otherwise, use the long-form textgrid format.</span>
<span class="sd">                For backwards compatibility, is True by default. Ignored if</span>
<span class="sd">                format is not &#39;Textgrid&#39;</span>
<span class="sd">            outputFormat (str): one of [&#39;textgrid&#39;, &#39;json&#39;]</span>
<span class="sd">            ignoreBlankSpaces (bool): if False, blank sections in interval</span>
<span class="sd">                tiers will be filled in with an empty interval</span>
<span class="sd">                (with a label of &quot;&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">outputFormat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_OUTPUT_FORMATS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BadFormatException</span><span class="p">(</span><span class="n">outputFormat</span><span class="p">,</span> <span class="n">SUPPORTED_OUTPUT_FORMATS</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outputFormat</span> <span class="o">==</span> <span class="n">TEXTGRID</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">useShortForm</span><span class="p">:</span>
                <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToShortTextForm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">minimumIntervalLength</span><span class="p">,</span>
                    <span class="n">minTimestamp</span><span class="p">,</span>
                    <span class="n">maxTimestamp</span><span class="p">,</span>
                    <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToLongTextForm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">minimumIntervalLength</span><span class="p">,</span>
                    <span class="n">minTimestamp</span><span class="p">,</span>
                    <span class="n">maxTimestamp</span><span class="p">,</span>
                    <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">outputFormat</span> <span class="o">==</span> <span class="n">JSON</span><span class="p">:</span>
            <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToJson</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">minimumIntervalLength</span><span class="p">,</span>
                <span class="n">minTimestamp</span><span class="p">,</span>
                <span class="n">maxTimestamp</span><span class="p">,</span>
                <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outputTxt</span><span class="p">)</span>
</pre></div>

        </details>

    

                            <div id="Textgrid.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Textgrid</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;A container that stores and operates over interval and point tiers&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Preserves the order of the tiers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>A container that stores and operates over interval and point tiers</p>
</div>


                            </div>
                            <div id="Textgrid.addTier" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.addTier">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">addTier</span><span class="signature">(self, tier, tierIndex=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">addTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tier</span><span class="p">,</span> <span class="n">tierIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a tier to this textgrid.</span>

<span class="sd">        Args:</span>
<span class="sd">            tier (TextgridTier):</span>
<span class="sd">            tierIndex (int): if specified, insert the tier into the specified position</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">tierIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">tierIndex</span><span class="p">,</span> <span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tier</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tier</span>

        <span class="n">minV</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">minV</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minV</span>

        <span class="n">maxV</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">maxV</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxV</span>
</pre></div>

        </details>

            <div class="docstring"><p>Add a tier to this textgrid.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tier (TextgridTier):</strong> </li>
<li><strong>tierIndex (int):</strong>  if specified, insert the tier into the specified position</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.appendTextgrid" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.appendTextgrid">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">appendTextgrid</span><span class="signature">(self, tg, onlyMatchingNames=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">appendTextgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tg</span><span class="p">,</span> <span class="n">onlyMatchingNames</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append one textgrid to the end of this one</span>

<span class="sd">        Args:</span>
<span class="sd">            tg (Textgrid): the tier to add to this one</span>
<span class="sd">            onlyMatchingNames (bool): if False, tiers that don&#39;t appear in both</span>
<span class="sd">                textgrids will also appear</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="n">minTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">maxTime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">tg</span><span class="o">.</span><span class="n">maxTimestamp</span>

        <span class="c1"># Get all tier names.  Ordered first by this textgrid and</span>
        <span class="c1"># then by the other textgrid.</span>
        <span class="n">combinedTierNameList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">combinedTierNameList</span><span class="p">:</span>
                <span class="n">combinedTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Determine the tier names that will be in the final textgrid</span>
        <span class="n">finalTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">onlyMatchingNames</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">finalTierNameList</span> <span class="o">=</span> <span class="n">combinedTierNameList</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">combinedTierNameList</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                        <span class="n">finalTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Add tiers from this textgrid</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">finalTierNameList</span><span class="p">:</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                <span class="n">retTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="c1"># Add tiers from the given textgrid</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">finalTierNameList</span><span class="p">:</span>
                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">)</span>

                <span class="n">appendTier</span> <span class="o">=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
                    <span class="n">newEntryList</span> <span class="o">=</span> <span class="n">retTG</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span><span class="o">.</span><span class="n">entryList</span>
                    <span class="n">newEntryList</span> <span class="o">+=</span> <span class="n">appendTier</span><span class="o">.</span><span class="n">entryList</span>

                    <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
                        <span class="n">entryList</span><span class="o">=</span><span class="n">newEntryList</span><span class="p">,</span>
                        <span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span>
                        <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">retTG</span><span class="o">.</span><span class="n">replaceTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">appendTier</span>
                    <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">minTimestamp</span><span class="o">=</span><span class="n">minTime</span><span class="p">,</span> <span class="n">maxTimestamp</span><span class="o">=</span><span class="n">maxTime</span><span class="p">)</span>
                    <span class="n">retTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retTG</span>
</pre></div>

        </details>

            <div class="docstring"><p>Append one textgrid to the end of this one</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>tg (Textgrid):</strong>  the tier to add to this one</li>
<li><strong>onlyMatchingNames (bool):</strong>  if False, tiers that don't appear in both
textgrids will also appear</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid: the modified version of the current textgrid</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.crop" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.crop">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">crop</span><span class="signature">(self, cropStart, cropEnd, mode, rebaseToZero)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a textgrid where all intervals fit within the crop region</span>

<span class="sd">        Args:</span>
<span class="sd">            cropStart (float):</span>
<span class="sd">            cropEnd (float):</span>
<span class="sd">            mode (str): one of [&#39;strict&#39;, &#39;lax&#39;, &#39;truncated&#39;]</span>
<span class="sd">                - &#39;strict&#39;, only intervals wholly contained by the crop</span>
<span class="sd">                    interval will be kept</span>
<span class="sd">                - &#39;lax&#39;, partially contained intervals will be kept</span>
<span class="sd">                - &#39;truncated&#39;, partially contained intervals will be</span>
<span class="sd">                    truncated to fit within the crop region.</span>
<span class="sd">            rebaseToZero (bool): if True, the cropped textgrid values will be</span>
<span class="sd">                subtracted by the cropStart</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;strict&quot;</span><span class="p">,</span> <span class="s2">&quot;lax&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">rebaseToZero</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span> <span class="o">-</span> <span class="n">cropStart</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minT</span> <span class="o">=</span> <span class="n">cropStart</span>
            <span class="n">maxT</span> <span class="o">=</span> <span class="n">cropEnd</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="n">minT</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxT</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">cropStart</span><span class="p">,</span> <span class="n">cropEnd</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rebaseToZero</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTG</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a textgrid where all intervals fit within the crop region</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cropStart (float):</strong> </li>
<li><strong>cropEnd (float):</strong> </li>
<li><strong>mode (str):</strong>  one of ['strict', 'lax', 'truncated']
<ul>
<li>'strict', only intervals wholly contained by the crop
interval will be kept</li>
<li>'lax', partially contained intervals will be kept</li>
<li>'truncated', partially contained intervals will be
truncated to fit within the crop region.</li>
</ul></li>
<li><strong>rebaseToZero (bool):</strong>  if True, the cropped textgrid values will be
subtracted by the cropStart</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid: the modified version of the current textgrid</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.eraseRegion" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.eraseRegion">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">eraseRegion</span><span class="signature">(self, start, stop, doShrink=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">eraseRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">doShrink</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a region in a tier blank (removes all contained entries)</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            stop (float):</span>
<span class="sd">            doShrink (bool): if True, all entries appearing after the</span>
<span class="sd">                erased interval will be shifted to fill the void (ie</span>
<span class="sd">                the duration of the textgrid will be reduced by</span>
<span class="sd">                *start* - *stop*)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

        <span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span>
        <span class="k">if</span> <span class="n">doShrink</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">maxTimestamp</span> <span class="o">-=</span> <span class="n">diff</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">eraseRegion</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;truncate&quot;</span><span class="p">,</span> <span class="n">doShrink</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="n">maxTimestamp</span>

        <span class="k">return</span> <span class="n">newTG</span>
</pre></div>

        </details>

            <div class="docstring"><p>Makes a region in a tier blank (removes all contained entries)</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start (float):</strong> </li>
<li><strong>stop (float):</strong> </li>
<li><strong>doShrink (bool):</strong>  if True, all entries appearing after the
erased interval will be shifted to fill the void (ie
the duration of the textgrid will be reduced by
<em>start</em> - <em>stop</em>)</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid: the modified version of the current textgrid</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.editTimestamps" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.editTimestamps">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">editTimestamps</span><span class="signature">(self, offset, allowOvershoot=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">editTimestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies all timestamps by a constant amount</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (float): the amount to offset in seconds</span>
<span class="sd">            allowOvershoot (bool): if True, entries can go</span>
<span class="sd">                beyond the min and max timestamp set by the</span>
<span class="sd">                Textgrid</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tier</span><span class="o">.</span><span class="n">entryList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">editTimestamps</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">allowOvershoot</span><span class="p">)</span>

            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tg</span>
</pre></div>

        </details>

            <div class="docstring"><p>Modifies all timestamps by a constant amount</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>offset (float):</strong>  the amount to offset in seconds</li>
<li><strong>allowOvershoot (bool):</strong>  if True, entries can go
beyond the min and max timestamp set by the
Textgrid</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid: the modified version of the current textgrid</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.insertSpace" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.insertSpace">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">insertSpace</span><span class="signature">(self, start, duration, collisionCode=None)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">insertSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a blank region into a textgrid</span>

<span class="sd">        Every item that occurs after *start* will be pushed back by</span>
<span class="sd">        *duration* seconds</span>

<span class="sd">        Args:</span>
<span class="sd">            start (float):</span>
<span class="sd">            duration (float):</span>
<span class="sd">            collisionCode (str): Determines behaviour in the event that an</span>
<span class="sd">                interval stradles the starting point.</span>
<span class="sd">                One of [&#39;stretch&#39;, &#39;split&#39;, &#39;no change&#39;, None]</span>
<span class="sd">                - &#39;stretch&#39; stretches the interval by /duration/ amount</span>
<span class="sd">                - &#39;split&#39; splits the interval into two--everything to the</span>
<span class="sd">                    right of &#39;start&#39; will be advanced by &#39;duration&#39; seconds</span>
<span class="sd">                - &#39;no change&#39; leaves the interval as is with no change</span>
<span class="sd">                - None or any other value throws an AssertionError</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newTG</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">minTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minTimestamp</span>
        <span class="n">newTG</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxTimestamp</span> <span class="o">+</span> <span class="n">duration</span>

        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">newTier</span> <span class="o">=</span> <span class="n">tier</span><span class="o">.</span><span class="n">insertSpace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">collisionCode</span><span class="p">)</span>
            <span class="n">newTG</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newTG</span>
</pre></div>

        </details>

            <div class="docstring"><p>Inserts a blank region into a textgrid</p>

<p>Every item that occurs after <em>start</em> will be pushed back by
<em>duration</em> seconds</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start (float):</strong> </li>
<li><strong>duration (float):</strong> </li>
<li><strong>collisionCode (str):</strong>  Determines behaviour in the event that an
interval stradles the starting point.
One of ['stretch', 'split', 'no change', None]
<ul>
<li>'stretch' stretches the interval by /duration/ amount</li>
<li>'split' splits the interval into two--everything to the
right of 'start' will be advanced by 'duration' seconds</li>
<li>'no change' leaves the interval as is with no change</li>
<li>None or any other value throws an AssertionError</li>
</ul></li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid: the modified version of the current textgrid</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.mergeTiers" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.mergeTiers">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">mergeTiers</span><span class="signature">(self, includeFunc=None, tierList=None, preserveOtherTiers=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">mergeTiers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includeFunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tierList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preserveOtherTiers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine tiers</span>

<span class="sd">        Args:</span>
<span class="sd">            includeFunc (functor): regulates which intervals to include in the</span>
<span class="sd">                merging with all others being tossed (default accepts all)</span>
<span class="sd">            tierList (list): A list of tier names to combine. If none, combine</span>
<span class="sd">                all tiers.</span>
<span class="sd">            preserveOtherTiers (bool): If false, uncombined tiers are not</span>
<span class="sd">                included in the output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Textgrid: the modified version of the current textgrid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tierList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tierList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span>

        <span class="k">if</span> <span class="n">includeFunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">includeFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">entryList</span><span class="p">:</span> <span class="kc">True</span>

        <span class="c1"># Determine the tiers to merge</span>
        <span class="n">intervalTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pointTierNameList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">tierList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">IntervalTier</span><span class="p">):</span>
                <span class="n">intervalTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tier</span><span class="p">,</span> <span class="n">PointTier</span><span class="p">):</span>
                <span class="n">pointTierNameList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tierName</span><span class="p">)</span>

        <span class="c1"># Merge the interval tiers</span>
        <span class="n">intervalTier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervalTierNameList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">intervalTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">intervalTierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">intervalTierNameList</span><span class="p">:</span>
            <span class="n">intervalTier</span> <span class="o">=</span> <span class="n">intervalTier</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">])</span>

        <span class="c1"># Merge the point tiers</span>
        <span class="n">pointTier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointTierNameList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pointTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">pointTierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">pointTierNameList</span><span class="p">:</span>
            <span class="n">pointTier</span> <span class="o">=</span> <span class="n">pointTier</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">])</span>

        <span class="c1"># Create the final textgrid to output</span>
        <span class="n">tg</span> <span class="o">=</span> <span class="n">Textgrid</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">intervalTier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">intervalTier</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pointTier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">pointTier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tg</span>
</pre></div>

        </details>

            <div class="docstring"><p>Combine tiers</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>includeFunc (functor):</strong>  regulates which intervals to include in the
merging with all others being tossed (default accepts all)</li>
<li><strong>tierList (list):</strong>  A list of tier names to combine. If none, combine
all tiers.</li>
<li><strong>preserveOtherTiers (bool):</strong>  If false, uncombined tiers are not
included in the output.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid: the modified version of the current textgrid</p>
</blockquote>
</div>


                            </div>
                            <div id="Textgrid.new" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.new">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">new</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of this Textgrid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a copy of this Textgrid</p>
</div>


                            </div>
                            <div id="Textgrid.renameTier" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.renameTier">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">renameTier</span><span class="signature">(self, oldName, newName)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">renameTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldName</span><span class="p">,</span> <span class="n">newName</span><span class="p">):</span>
        <span class="n">oldTier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">oldName</span><span class="p">]</span>
        <span class="n">tierIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">oldName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeTier</span><span class="p">(</span><span class="n">oldName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">oldTier</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">newName</span><span class="p">,</span> <span class="n">oldTier</span><span class="o">.</span><span class="n">entryList</span><span class="p">),</span> <span class="n">tierIndex</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Textgrid.removeTier" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.removeTier">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">removeTier</span><span class="signature">(self, name)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">removeTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Textgrid.replaceTier" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.replaceTier">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">replaceTier</span><span class="signature">(self, name, newTier)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">replaceTier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">newTier</span><span class="p">):</span>
        <span class="n">tierIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tierNameList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removeTier</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTier</span><span class="p">(</span><span class="n">newTier</span><span class="p">,</span> <span class="n">tierIndex</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Textgrid.save" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Textgrid.save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">save</span><span class="signature">(
    self,
    fn,
    minimumIntervalLength=1e-08,
    minTimestamp=None,
    maxTimestamp=None,
    useShortForm=True,
    outputFormat=&#39;textgrid&#39;,
    ignoreBlankSpaces=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">,</span>
        <span class="n">minimumIntervalLength</span><span class="o">=</span><span class="n">MIN_INTERVAL_LENGTH</span><span class="p">,</span>
        <span class="n">minTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxTimestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">useShortForm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">outputFormat</span><span class="o">=</span><span class="n">TEXTGRID</span><span class="p">,</span>
        <span class="n">ignoreBlankSpaces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To save the current textgrid</span>

<span class="sd">        Args:</span>
<span class="sd">            fn (str): the fullpath filename of the output</span>
<span class="sd">            minimumIntervalLength (float): any labeled intervals smaller</span>
<span class="sd">                than this will be removed, useful for removing ultrashort</span>
<span class="sd">                or fragmented intervals; if None, don&#39;t remove any.</span>
<span class="sd">                Removed intervals are merged (without their label) into</span>
<span class="sd">                adjacent entries.</span>
<span class="sd">            minTimestamp (float): the minTimestamp of the saved Textgrid;</span>
<span class="sd">                if None, use whatever is defined in the Textgrid object.</span>
<span class="sd">                If minTimestamp is larger than timestamps in your textgrid,</span>
<span class="sd">                an exception will be thrown.</span>
<span class="sd">            maxTimestamp (float): the maxTimestamp of the saved Textgrid;</span>
<span class="sd">                if None, use whatever is defined in the Textgrid object.</span>
<span class="sd">                If maxTimestamp is smaller than timestamps in your textgrid,</span>
<span class="sd">                an exception will be thrown.</span>
<span class="sd">            useShortForm (bool): if True, save the textgrid as a short</span>
<span class="sd">                textgrid. Otherwise, use the long-form textgrid format.</span>
<span class="sd">                For backwards compatibility, is True by default. Ignored if</span>
<span class="sd">                format is not &#39;Textgrid&#39;</span>
<span class="sd">            outputFormat (str): one of [&#39;textgrid&#39;, &#39;json&#39;]</span>
<span class="sd">            ignoreBlankSpaces (bool): if False, blank sections in interval</span>
<span class="sd">                tiers will be filled in with an empty interval</span>
<span class="sd">                (with a label of &quot;&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">outputFormat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_OUTPUT_FORMATS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BadFormatException</span><span class="p">(</span><span class="n">outputFormat</span><span class="p">,</span> <span class="n">SUPPORTED_OUTPUT_FORMATS</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outputFormat</span> <span class="o">==</span> <span class="n">TEXTGRID</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">useShortForm</span><span class="p">:</span>
                <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToShortTextForm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">minimumIntervalLength</span><span class="p">,</span>
                    <span class="n">minTimestamp</span><span class="p">,</span>
                    <span class="n">maxTimestamp</span><span class="p">,</span>
                    <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToLongTextForm</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">minimumIntervalLength</span><span class="p">,</span>
                    <span class="n">minTimestamp</span><span class="p">,</span>
                    <span class="n">maxTimestamp</span><span class="p">,</span>
                    <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">outputFormat</span> <span class="o">==</span> <span class="n">JSON</span><span class="p">:</span>
            <span class="n">outputTxt</span> <span class="o">=</span> <span class="n">_tgToJson</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">minimumIntervalLength</span><span class="p">,</span>
                <span class="n">minTimestamp</span><span class="p">,</span>
                <span class="n">maxTimestamp</span><span class="p">,</span>
                <span class="n">ignoreBlankSpaces</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">outputTxt</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>To save the current textgrid</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>fn (str):</strong>  the fullpath filename of the output</li>
<li><strong>minimumIntervalLength (float):</strong>  any labeled intervals smaller
than this will be removed, useful for removing ultrashort
or fragmented intervals; if None, don't remove any.
Removed intervals are merged (without their label) into
adjacent entries.</li>
<li><strong>minTimestamp (float):</strong>  the minTimestamp of the saved Textgrid;
if None, use whatever is defined in the Textgrid object.
If minTimestamp is larger than timestamps in your textgrid,
an exception will be thrown.</li>
<li><strong>maxTimestamp (float):</strong>  the maxTimestamp of the saved Textgrid;
if None, use whatever is defined in the Textgrid object.
If maxTimestamp is smaller than timestamps in your textgrid,
an exception will be thrown.</li>
<li><strong>useShortForm (bool):</strong>  if True, save the textgrid as a short
textgrid. Otherwise, use the long-form textgrid format.
For backwards compatibility, is True by default. Ignored if
format is not 'Textgrid'</li>
<li><strong>outputFormat (str):</strong>  one of ['textgrid', 'json']</li>
<li><strong>ignoreBlankSpaces (bool):</strong>  if False, blank sections in interval
tiers will be filled in with an empty interval
(with a label of "")</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>None</p>
</blockquote>
</div>


                            </div>
                </section>
                <section id="openTextgrid">
                            <div class="attr function"><a class="headerlink" href="#openTextgrid">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">openTextgrid</span><span class="signature">(fnFullPath, readRaw=False, readAsJson=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">openTextgrid</span><span class="p">(</span><span class="n">fnFullPath</span><span class="p">,</span> <span class="n">readRaw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">readAsJson</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Opens a textgrid for editing</span>

<span class="sd">    Args:</span>
<span class="sd">        fnFullPath (str): the path to the textgrid to open</span>
<span class="sd">        readRaw (bool): points and intervals with an empty label</span>
<span class="sd">            &#39;&#39; are removed unless readRaw=True</span>
<span class="sd">        readAsJson (bool): if True, assume the Textgrid is saved</span>
<span class="sd">            as Json rather than in its native format</span>

<span class="sd">    Returns:</span>
<span class="sd">        Textgrid</span>

<span class="sd">    https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fnFullPath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-16&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fnFullPath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">readAsJson</span><span class="p">:</span>
        <span class="n">tgAsDict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">textgrid</span> <span class="o">=</span> <span class="n">_dictionaryToTg</span><span class="p">(</span><span class="n">tgAsDict</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">caseA</span> <span class="o">=</span> <span class="s2">&quot;ooTextFile short&quot;</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="n">caseB</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;item ?\[&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">caseA</span> <span class="ow">or</span> <span class="n">caseB</span><span class="p">:</span>
            <span class="n">textgrid</span> <span class="o">=</span> <span class="n">_parseShortTextgrid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">textgrid</span> <span class="o">=</span> <span class="n">_parseNormalTextgrid</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">readRaw</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tierName</span> <span class="ow">in</span> <span class="n">textgrid</span><span class="o">.</span><span class="n">tierNameList</span><span class="p">:</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">textgrid</span><span class="o">.</span><span class="n">tierDict</span><span class="p">[</span><span class="n">tierName</span><span class="p">]</span>
            <span class="n">tier</span> <span class="o">=</span> <span class="n">_removeBlanks</span><span class="p">(</span><span class="n">tier</span><span class="p">)</span>
            <span class="n">textgrid</span><span class="o">.</span><span class="n">replaceTier</span><span class="p">(</span><span class="n">tierName</span><span class="p">,</span> <span class="n">tier</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">textgrid</span>
</pre></div>

        </details>

            <div class="docstring"><p>Opens a textgrid for editing</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>fnFullPath (str):</strong>  the path to the textgrid to open</li>
<li><strong>readRaw (bool):</strong>  points and intervals with an empty label
'' are removed unless readRaw=True</li>
<li><strong>readAsJson (bool):</strong>  if True, assume the Textgrid is saved
as Json rather than in its native format</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Textgrid</p>
</blockquote>

<p>https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html</p>
</div>


                </section>
                <section id="numToStr">
                            <div class="attr function"><a class="headerlink" href="#numToStr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">numToStr</span><span class="signature">(inputNum)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">numToStr</span><span class="p">(</span><span class="n">inputNum</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_isclose</span><span class="p">(</span><span class="n">inputNum</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">inputNum</span><span class="p">)):</span>
        <span class="n">retVal</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">inputNum</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">retVal</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">inputNum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">retVal</span>
</pre></div>

        </details>

    

                </section>
                <section id="strToIntOrFloat">
                            <div class="attr function"><a class="headerlink" href="#strToIntOrFloat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">strToIntOrFloat</span><span class="signature">(inputStr)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">strToIntOrFloat</span><span class="p">(</span><span class="n">inputStr</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">inputStr</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">inputStr</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">inputStr</span><span class="p">)</span>
</pre></div>

        </details>

    

                </section>
    </main>
</body>
</html>